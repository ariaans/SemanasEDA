<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸŒ Proyecto Semana 3 â€” Modelando un Mapa de TrÃ¡fico con Grafos Dirigidos y No Dirigidos</title>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            line-height: 1.6; 
            margin: 0; 
            padding: 20px; 
            background-color: #f8f9fa; 
            color: #333; 
        }
        h1, h2, h3 { color: #2c3e50; }
        h1 { 
            text-align: center; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            color: white; 
            padding: 20px; 
            border-radius: 10px; 
            margin-bottom: 10px;
        }
        .subtitle { 
            text-align: center; 
            font-style: italic; 
            color: #7f8c8d; 
            margin-bottom: 20px; 
        }
        nav { 
            display: flex; 
            justify-content: center; 
            margin: 20px 0; 
            flex-wrap: wrap; 
            gap: 5px;
        }
        nav button { 
            background: #3498db; 
            color: white; 
            border: none; 
            padding: 10px 20px; 
            margin: 2px; 
            border-radius: 5px; 
            cursor: pointer; 
            transition: all 0.3s ease;
        }
        nav button:hover { 
            background: #2980b9; 
            transform: translateY(-2px);
        }
        nav button.active {
            background: #27ae60;
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
        }
        section { 
            margin: 20px 0; 
            padding: 25px; 
            background: white; 
            border-radius: 10px; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.1); 
            display: none;
        }
        section.active { display: block; }
        
        .emoji { font-size: 1.5em; }
        table { 
            width: 100%; 
            border-collapse: collapse; 
            margin: 15px 0; 
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        th, td { 
            border: 1px solid #ddd; 
            padding: 12px 8px; 
            text-align: left; 
        }
        th { 
            background: linear-gradient(135deg, #3498db, #2980b9); 
            color: white;
            font-weight: 600;
        }
        tr:nth-child(even) { background-color: #f8f9fa; }
        tr:hover { background-color: #e8f4fd; }
        
        pre { 
            background: #2c3e50; 
            color: #ecf0f1; 
            padding: 20px; 
            border-radius: 8px; 
            overflow-x: auto; 
            border-left: 4px solid #3498db;
            font-family: 'Courier New', monospace;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        /* CÃ³digo simple sin syntax highlighting para evitar superposiciones */
        .codigo-simple {
            background: #f8f9fa;
            color: #2c3e50;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            border-left: 4px solid #3498db;
            font-family: 'Courier New', monospace;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        code { 
            background: #f4f4f4; 
            padding: 3px 6px; 
            border-radius: 4px; 
            font-family: 'Courier New', monospace;
        }
        
        .actividad { 
            background: linear-gradient(135deg, #e8f5e8, #f0f8f0); 
            padding: 18px; 
            border-left: 5px solid #27ae60; 
            margin: 18px 0;
            border-radius: 0 8px 8px 0;
            box-shadow: 0 2px 6px rgba(39, 174, 96, 0.1);
        }
        .actividad h3, .actividad h4 { 
            color: #27ae60; 
            margin-top: 0; 
        }
        
        .reflexion { 
            background: linear-gradient(135deg, #fff3cd, #fef9e7); 
            padding: 18px; 
            border-left: 5px solid #ffc107; 
            margin: 18px 0;
            border-radius: 0 8px 8px 0;
        }
        .reflexion h3, .reflexion h4 { 
            color: #856404; 
            margin-top: 0; 
        }
        
        .checkpoint {
            background: linear-gradient(135deg, #e1f5fe, #f0f9ff);
            padding: 18px;
            border-left: 5px solid #03a9f4;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        .checkpoint h4 { 
            color: #0277bd; 
            margin-top: 0; 
        }
        
        .conexion {
            background: linear-gradient(135deg, #fff3cd, #fef9e7);
            padding: 15px;
            border-left: 5px solid #ffc107;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        .conexion h4 { 
            color: #856404; 
            margin-top: 0; 
        }
        
        .mapa-mental { 
            text-align: center; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            color: white; 
            padding: 15px; 
            margin: 20px 0; 
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        .mapa-mental h4 { 
            color: white; 
            margin-top: 0; 
        }
        
        .evaluacion {
            background: linear-gradient(135deg, #f8d7da, #f5c6cb);
            padding: 18px;
            border-left: 5px solid #dc3545;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        .evaluacion h3, .evaluacion h4 { 
            color: #721c24; 
            margin-top: 0; 
        }
        
        .grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 20px; 
            margin: 20px 0; 
        }
        @media (max-width: 768px) {
            .grid { grid-template-columns: 1fr; }
            nav { flex-direction: column; align-items: center; }
        }
        
        .nivel-basico { border-left-color: #28a745; background: linear-gradient(135deg, #d4edda, #d1ecf1); }
        .nivel-intermedio { border-left-color: #ffc107; background: linear-gradient(135deg, #fff3cd, #fef9e7); }
        .nivel-avanzado { border-left-color: #dc3545; background: linear-gradient(135deg, #f8d7da, #f5c6cb); }
        
        details {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            background: #f8f9fa;
        }
        summary {
            cursor: pointer;
            font-weight: 600;
            color: #0066cc;
            padding: 5px 0;
        }
        summary:hover { color: #004499; }
        
        .codigo-error { 
            background: #f8d7da; 
            border-left: 4px solid #dc3545; 
            padding: 10px; 
            margin: 10px 0; 
            border-radius: 0 6px 6px 0;
        }
        .codigo-correcto { 
            background: #d4edda; 
            border-left: 4px solid #28a745; 
            padding: 10px; 
            margin: 10px 0; 
            border-radius: 0 6px 6px 0;
        }
        
        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }
        .btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        .btn-success { background: #27ae60; }
        .btn-success:hover { background: #229954; }
    </style>
</head>
<body>

    <h1>ğŸŒ Proyecto Semana 3 â€” Modelando un Mapa de TrÃ¡fico con Grafos Dirigidos y No Dirigidos</h1>
    <p class="subtitle">Estructuras de Datos Avanzadas â€¢ Proyecto PrÃ¡ctico Integrador</p>

    <nav>
        <button onclick="showSection('intro')" class="nav-btn active">IntroducciÃ³n</button>
        <button onclick="showSection('objetivos')" class="nav-btn">Objetivos</button>
        <button onclick="showSection('diseno')" class="nav-btn">DiseÃ±o</button>
        <button onclick="showSection('csharp')" class="nav-btn">C#</button>
        <button onclick="showSection('python')" class="nav-btn">Python</button>
        <button onclick="showSection('analisis')" class="nav-btn">AnÃ¡lisis</button>
        <button onclick="showSection('evaluacion')" class="nav-btn">EvaluaciÃ³n</button>
        <button onclick="showSection('diferenciacion')" class="nav-btn">Niveles</button>
        <button onclick="showSection('reflexion')" class="nav-btn">ReflexiÃ³n</button>
    </nav>

    <section id="intro" class="active">
        <h2>ğŸš€ IntroducciÃ³n: Â¡Bienvenidos al Proyecto PrÃ¡ctico!</h2>
        <p>Â¡Hola, estudiantes! Seguimos trabajando en Estructuras de Datos Avanzadas. Hoy, vamos a aplicar todo lo que aprendimos en la Semana 3 sobre <strong>TeorÃ­a de Grafos</strong>. Imaginen que estamos construyendo un <em>mapa de una ciudad pequeÃ±a</em>: intersecciones (como nodos en una red) y calles (como conexiones). Usaremos grafos para modelarlo de forma simple y realista.</p>
        
        <p>En tÃ©rminos generales, un grafo es como un "mapa de relaciones": Â¿cÃ³mo se conectan las cosas? AquÃ­, crearemos <strong>dos versiones</strong>: una con calles que van en <em>ambos sentidos</em> (no dirigido, como una avenida libre) y otra con calles de <em>un solo sentido</em> (dirigido, como una calle con flecha de trÃ¡fico). Lo haremos paso a paso, con explicaciones <em>simples y amplias</em>, como si estuviÃ©ramos en clase charlando con un cafÃ© en mano.</p>
        
        <p><strong>Â¿Por quÃ© esto importa?</strong> En la vida real, apps como Google Maps usan grafos para calcular rutas. Â¡Ustedes lo construirÃ¡n hoy! Al final, tendrÃ¡n cÃ³digo en C# y Python, y un reporte listo para entregar.</p>
        
        <div class="mapa-mental">
            <h4>ğŸ§­ Mapa Mental del Proyecto</h4>
            <p>Idea Real (Mapa de Ciudad) â†’ Modelado (VÃ©rtices = Intersecciones, Aristas = Calles) â†’ ElecciÃ³n (Lista de Adyacencia, porque es eficiente) â†’ ImplementaciÃ³n (CÃ³digo + Pruebas) â†’ AnÃ¡lisis (Grados y Vecinos)</p>
        </div>
        
        <p>Â¡Continuemos! Sigan leyendo secciÃ³n por secciÃ³n.</p>
        
        <button class="btn" onclick="showSection('objetivos')">Continuar â†’ Objetivos</button>
    </section>

    <section id="objetivos">
        <h2>ğŸ¯ Objetivos de la SesiÃ³n: Â¿QuÃ© LograrÃ¡n Hoy?</h2>
        <p>Piensen en esto como una receta de cocina: cada paso nos lleva a un plato delicioso (Â¡su proyecto!). Al final de esta guÃ­a:</p>
        
        <div class="grid">
            <div class="actividad">
                <h4>ğŸ“š Objetivos Conceptuales</h4>
                <ul>
                    <li><strong>EntenderÃ¡n grafos dirigidos vs. no dirigidos</strong>: Con ejemplos cotidianos, como "puedes ir y volver" (no dirigido) vs. "solo adelante" (dirigido)</li>
                    <li><strong>DominarÃ¡n listas de adyacencia</strong>: Â¿Por quÃ© son eficientes para grafos dispersos?</li>
                    <li><strong>AnalizarÃ¡n trade-offs</strong>: Memoria vs. tiempo de consulta</li>
                </ul>
            </div>
            <div class="actividad">
                <h4>ğŸ’» Objetivos PrÃ¡cticos</h4>
                <ul>
                    <li><strong>ModelarÃ¡n un mapa realista</strong>: Con 8 intersecciones y 12 calles, usando pesos (distancias en km)</li>
                    <li><strong>ImplementarÃ¡n en C# y Python</strong>: VerÃ¡n cÃ³mo los lenguajes se complementan</li>
                    <li><strong>EntregarÃ¡n un reporte profesional</strong>: Justificando sus decisiones tÃ©cnicas</li>
                </ul>
            </div>
        </div>
        
        <div class="actividad">
            <h4>ğŸ’¡ Consejo PedagÃ³gico</h4>
            <p>TÃ³mense 5 minutos para dibujar su propio mapa en papel antes de codificar. Â¡Ayuda muchÃ­simo a visualizar los conceptos!</p>
        </div>

        <div class="mapa-mental">
            <h4>ğŸ§­ Hoja de Ruta del Proyecto</h4>
            <p>
                <strong>Acabas de ver:</strong> Los objetivos y el "Â¿por quÃ©?" del proyecto<br>
                <strong>Sigues con:</strong> DiseÃ±o del mapa (el "Â¿quÃ©?" vamos a construir)<br>
                <strong>DespuÃ©s:</strong> ImplementaciÃ³n (el "Â¿cÃ³mo?" lo programamos)
            </p>
        </div>
        
        <button class="btn" onclick="showSection('diseno')">Continuar â†’ DiseÃ±o del Mapa</button>
    </section>

    <section id="diseno">
        <h2>ğŸ§© DiseÃ±o del Mapa: VisualizaciÃ³n Paso a Paso</h2>
        <p>Antes de tocar cÃ³digo, diseÃ±emos en papel. Imaginen una ciudad chiquita: el <strong>Centro (A)</strong> conectado al <strong>Norte (B)</strong>, <strong>Sur (C)</strong>, etc. Usamos letras simples para vÃ©rtices (nodos).</p>

        <div class="grid">
            <div class="actividad">
                <h3>ğŸ›ï¸ VÃ©rtices (Intersecciones)</h3>
                <table>
                    <tr><th>ID</th><th>DescripciÃ³n</th></tr>
                    <tr><td><strong>A</strong></td><td>Centro Comercial</td></tr>
                    <tr><td><strong>B</strong></td><td>Zona Norte</td></tr>
                    <tr><td><strong>C</strong></td><td>Zona Sur</td></tr>
                    <tr><td><strong>D</strong></td><td>Este Industrial</td></tr>
                    <tr><td><strong>E</strong></td><td>Oeste Residencial</td></tr>
                    <tr><td><strong>F</strong></td><td>Zona Industrial</td></tr>
                    <tr><td><strong>G</strong></td><td>Hospital</td></tr>
                    <tr><td><strong>H</strong></td><td>Estadio</td></tr>
                </table>
            </div>
            
            <div class="actividad">
                <h3>ğŸ›£ï¸ Aristas (Calles)</h3>
                <div style="margin-bottom: 15px;">
                    <h4 style="color: #27ae60;">â†”ï¸ No Dirigidas (Bidireccionales)</h4>
                    <ul style="font-family: monospace; font-size: 14px;">
                        <li>A â†” B: 2.0 km</li>
                        <li>A â†” C: 3.0 km</li>
                        <li>B â†” D: 1.0 km</li>
                        <li>C â†” E: 4.0 km</li>
                        <li>D â†” F: 5.0 km</li>
                        <li>E â†” F: 2.0 km</li>
                        <li>G â†” H: 6.0 km</li>
                    </ul>
                </div>
                
                <div>
                    <h4 style="color: #e74c3c;">â†’ Dirigidas (Un solo sentido)</h4>
                    <ul style="font-family: monospace; font-size: 14px;">
                        <li>A â†’ G: 1.0 km (al hospital)</li>
                        <li>B â†’ H: 3.0 km (al estadio)</li>
                        <li>C â†’ D: 2.0 km</li>
                        <li>F â†’ E: 4.0 km</li>
                        <li>H â†’ A: 5.0 km (vuelta al centro)</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="actividad">
            <h3>ğŸ—ºï¸ Diagrama Simplificado</h3>
            <pre style="background: #f8f9fa; color: #333; padding: 15px; font-family: monospace; font-size: 12px; line-height: 1.3; border-left: 4px solid #3498db;">
    B(Norte) â†â†’ A(Centro) â†â†’ C(Sur)
    â†“ 1km         â†“ 1km         â†“ 2km
    D(Este)       G(Hospital)   E(Oeste)
    â†“ 5km                       â†‘ 4km
    F(Industrial) â†â†â†â†â†â†â†â†â†â†â† (Fâ†’E: 4km)
    
    H(Estadio) â†â†’ G(Hospital) (6km)
    â†‘
    â””â”€â”€â”€ A(Centro) (Hâ†’A: 5km)
            </pre>
            <p style="font-size: 0.9em; color: #666;">
                <strong>Leyenda:</strong> â†â†’ bidireccional, â†’ unidireccional
            </p>
        </div>

        <div class="actividad" style="background: #fff3cd; border-left: 5px solid #ffc107;">
            <h3>âœï¸ Actividad PrÃ¡ctica (5 min)</h3>
            <ol>
                <li>Dibuja este mapa en papel usando cÃ­rculos para vÃ©rtices</li>
                <li>Usa lÃ­neas con doble flecha (â†”) para no dirigidas</li>
                <li>Usa lÃ­neas con una flecha (â†’) para dirigidas</li>
                <li>Etiqueta cada arista con su peso</li>
                <li><strong>Pregunta clave:</strong> Â¿CuÃ¡ntas conexiones totales tiene el vÃ©rtice A?</li>
            </ol>
            <details style="margin-top: 10px;">
                <summary><strong>ğŸ’¡ Ver respuesta</strong></summary>
                <div style="margin-top: 10px; padding: 10px; background: #f0f8ff; border-radius: 5px;">
                    <strong>Respuesta:</strong> El vÃ©rtice A tiene:<br>
                    â€¢ <strong>No dirigidas:</strong> Aâ†”B, Aâ†”C (2 conexiones bidireccionales)<br>
                    â€¢ <strong>Dirigidas:</strong> Aâ†’G (1 conexiÃ³n saliente)<br>
                    â€¢ <strong>Total grado de salida:</strong> 3 conexiones
                </div>
            </details>
        </div>

        <p><em>ExplicaciÃ³n tÃ©cnica:</em> En no dirigido, el grafo es "simÃ©trico" (si hay arista de u a v, tambiÃ©n de v a u). En dirigido, es "con flechas" (puede haber solo una direcciÃ³n, como en aeropuertos con pistas). Mezclamos para un mapa real: ~60% bidireccional. El grafo es <em>disperso</em> (pocas conexiones directas), por eso elegimos listas de adyacencia: Â¡ahorra espacio en la "memoria" del programa!</p>

        <div class="checkpoint">
            <h4>âœ… Checkpoint: Â¿Listos para Codificar?</h4>
            <p>Antes de pasar al cÃ³digo, asegÃºrate de que:</p>
            <ul>
                <li>âœ… Entiendes la diferencia entre Aâ†”B (bidireccional) y Aâ†’B (unidireccional)</li>
                <li>âœ… Sabes por quÃ© elegimos listas de adyacencia (memoria eficiente para grafos dispersos)</li>
                <li>âœ… Tienes claro el diseÃ±o de 8 vÃ©rtices y 12 aristas</li>
            </ul>
            <p><strong>ğŸ‘‰ Siguiente paso:</strong> Implementar la clase Graph en C# que materialice este diseÃ±o</p>
        </div>
        
        <button class="btn" onclick="showSection('csharp')">Continuar â†’ ImplementaciÃ³n C#</button>
    </section>

    <section id="csharp">
        <h2>ğŸ’» ImplementaciÃ³n en C#: Construyendo el Grafo</h2>
        <p>Ahora, Â¡manos a la obra! Usamos una clase <code>Graph&lt;T&gt;</code> genÃ©rica y robusta. Piensen en C# como un "constructor de edificios": sÃ³lido y estructurado.</p>
        
        <div class="actividad">
            <h4>ğŸ”§ CaracterÃ­sticas de Nuestra ImplementaciÃ³n</h4>
            <ul>
                <li><strong>GenÃ©rica:</strong> Funciona con cualquier tipo de dato (string, int, etc.)</li>
                <li><strong>Flexible:</strong> Soporta grafos dirigidos y no dirigidos</li>
                <li><strong>Eficiente:</strong> Usa listas de adyacencia para memoria optimizada</li>
                <li><strong>Robusta:</strong> Manejo de errores y validaciones incluidas</li>
            </ul>
        </div>

        <div class="codigo-correcto">
            <h4>âœ… CÃ³digo C# Corregido y Mejorado</h4>
        </div>

<div class="codigo-simple">
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

public class Graph<T> where T : IComparable<T>
{
    private readonly Dictionary<T, List<(T to, double weight)>> adjacencyList = new();
    
    // Agregar un vÃ©rtice al grafo
    public void AddVertex(T vertex)
    {
        if (!adjacencyList.ContainsKey(vertex))
        {
            adjacencyList[vertex] = new List<(T, double)>();
        }
    }
    
    // Agregar una arista (dirigida o no dirigida)
    public void AddEdge(T from, T to, double weight = 1.0, bool isDirected = true)
    {
        AddVertex(from);
        AddVertex(to);
        
        adjacencyList[from].Add((to, weight));
        
        if (!isDirected)
        {
            adjacencyList[to].Add((from, weight));
        }
    }
    
    // CORREGIDO: Exportar a archivo con deduplicaciÃ³n mejorada
    public void ExportToFile(string filename, bool includeWeights = true, bool deduplicateUndirected = false)
    {
        try
        {
            using var writer = new StreamWriter(filename);
            var processedEdges = new HashSet<string>();

            foreach (var vertex in adjacencyList.Keys.OrderBy(v => v))
            {
                foreach (var (neighbor, weight) in adjacencyList[vertex])
                {
                    if (deduplicateUndirected)
                    {
                        // Para grafos no dirigidos, crear clave Ãºnica ordenada
                        var vertexStr = vertex?.ToString() ?? "";
                        var neighborStr = neighbor?.ToString() ?? "";
                        
                        var edgeKey = vertex.CompareTo(neighbor) <= 0
                            ? $"{vertexStr}â†’{neighborStr}"
                            : $"{neighborStr}â†’{vertexStr}";
                        
                        if (!processedEdges.Add(edgeKey))
                            continue; // Saltar si ya fue procesada
                    }
                    
                    // Escribir la arista al archivo
                    var line = includeWeights 
                        ? $"{vertex} {neighbor} {weight:F1}"
                        : $"{vertex} {neighbor}";
                    writer.WriteLine(line);
                }
            }
            Console.WriteLine($"âœ… Archivo '{filename}' exportado exitosamente.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"âŒ Error al exportar archivo: {ex.Message}");
        }
    }
    
    public IEnumerable<T> GetVertices() => adjacencyList.Keys;
    
    public IEnumerable<(T neighbor, double weight)> GetNeighbors(T vertex)
    {
        return adjacencyList.TryGetValue(vertex, out var neighbors) 
            ? neighbors 
            : Enumerable.Empty<(T, double)>();
    }
    
    public bool HasEdge(T from, T to)
    {
        return adjacencyList.TryGetValue(from, out var neighbors) && 
               neighbors.Any(edge => EqualityComparer<T>.Default.Equals(edge.to, to));
    }
    
    public int GetOutDegree(T vertex)
    {
        return adjacencyList.TryGetValue(vertex, out var neighbors) ? neighbors.Count : 0;
    }
    
    public int GetInDegree(T vertex)
    {
        return adjacencyList.Values
            .SelectMany(neighbors => neighbors)
            .Count(edge => EqualityComparer<T>.Default.Equals(edge.to, vertex));
    }
    
    public void PrintGraph()
    {
        Console.WriteLine("=== Estructura del Grafo ===");
        foreach (var vertex in adjacencyList.Keys.OrderBy(v => v))
        {
            var neighbors = string.Join(", ", 
                adjacencyList[vertex].Select(edge => $"{edge.to}({edge.weight:F1})"));
            Console.WriteLine($"{vertex}: [{neighbors}]");
        }
    }
}

// Programa principal con el mapa de la ciudad
class Program
{
    static void Main()
    {
        Console.WriteLine("ğŸŒ === Generando Mapa de TrÃ¡fico === ğŸŒ");

        // Grafo No Dirigido (calles bidireccionales)
        var undirected = new Graph<string>();
        Console.WriteLine("\nğŸ›£ï¸ Agregando calles bidireccionales...");
        
        undirected.AddEdge("A", "B", 2.0, false);
        undirected.AddEdge("A", "C", 3.0, false);
        undirected.AddEdge("B", "D", 1.0, false);
        undirected.AddEdge("C", "E", 4.0, false);
        undirected.AddEdge("D", "F", 5.0, false);
        undirected.AddEdge("E", "F", 2.0, false);
        undirected.AddEdge("G", "H", 6.0, false);
        
        undirected.ExportToFile("edges_undirected.txt", includeWeights: true, deduplicateUndirected: true);

        // Grafo Dirigido (todas las aristas)
        var directed = new Graph<string>();
        Console.WriteLine("\nğŸš¦ Creando mapa completo con calles direccionales...");
        
        // Aristas dirigidas especÃ­ficas
        directed.AddEdge("A", "G", 1.0, true);
        directed.AddEdge("B", "H", 3.0, true);
        directed.AddEdge("C", "D", 2.0, true);
        directed.AddEdge("F", "E", 4.0, true);
        directed.AddEdge("H", "A", 5.0, true);
        
        // Agregar tambiÃ©n las bidireccionales como dirigidas
        directed.AddEdge("A", "B", 2.0, true);
        directed.AddEdge("B", "A", 2.0, true);
        directed.AddEdge("A", "C", 3.0, true);
        directed.AddEdge("C", "A", 3.0, true);
        directed.AddEdge("B", "D", 1.0, true);
        directed.AddEdge("D", "B", 1.0, true);
        directed.AddEdge("C", "E", 4.0, true);
        directed.AddEdge("E", "C", 4.0, true);
        directed.AddEdge("D", "F", 5.0, true);
        directed.AddEdge("F", "D", 5.0, true);
        directed.AddEdge("E", "F", 2.0, true);
        directed.AddEdge("F", "E", 2.0, true);
        directed.AddEdge("G", "H", 6.0, true);
        directed.AddEdge("H", "G", 6.0, true);
        
        directed.ExportToFile("edges_directed.txt", includeWeights: true, deduplicateUndirected: false);

        // Pruebas de funcionalidad
        Console.WriteLine("\nğŸ§ª === Pruebas de Funcionalidad ===");
        Console.WriteLine($"Grado de A (no dirigido): {undirected.GetOutDegree("A")} (esperado: 2)");
        Console.WriteLine($"Â¿Existe Aâ†”B no dirigido? {undirected.HasEdge("A", "B")} (esperado: True)");
        Console.WriteLine($"Â¿Existe Bâ†”A no dirigido? {undirected.HasEdge("B", "A")} (esperado: True)");
        
        Console.WriteLine($"\nGrado salida A (dirigido): {directed.GetOutDegree("A")}");
        Console.WriteLine($"Grado entrada A (dirigido): {directed.GetInDegree("A")}");
        Console.WriteLine($"Â¿Existe Aâ†’G dirigido? {directed.HasEdge("A", "G")} (esperado: True)");
        Console.WriteLine($"Â¿Existe Gâ†’A dirigido? {directed.HasEdge("G", "A")} (esperado: False)");
        
        Console.WriteLine("\nğŸ‰ Â¡Proyecto C# completado exitosamente!");
    }
}
</div>

        <div class="actividad">
            <h4>ğŸ”§ Mejoras Aplicadas</h4>
            <ul>
                <li>âœ… <strong>DeduplicaciÃ³n corregida:</strong> Usa CompareTo para ordenar vÃ©rtices consistentemente</li>
                <li>âœ… <strong>Manejo de errores:</strong> Try-catch en exportaciÃ³n de archivos</li>
                <li>âœ… <strong>MÃ©todos adicionales:</strong> GetInDegree() y PrintGraph() para anÃ¡lisis completo</li>
                <li>âœ… <strong>ValidaciÃ³n robusta:</strong> TryGetValue() en lugar de acceso directo al diccionario</li>
                <li>âœ… <strong>Salida informativa:</strong> Mensajes claros para debugging</li>
            </ul>
        </div>

        <div class="conexion">
            <h4>ğŸ”„ ConexiÃ³n C# â†’ Python</h4>
            <p>
                <strong>Lo que acabas de construir:</strong> Una clase Graph que puede exportar datos a archivos .txt<br>
                <strong>Lo que harÃ¡s ahora:</strong> Usar Python para cargar esos archivos y analizar el grafo<br>
                <strong>Â¿Por quÃ© esta combinaciÃ³n?</strong> C# es excelente para estructuras de datos robustas, Python es perfecto para anÃ¡lisis y visualizaciÃ³n de datos.
            </p>
        </div>
        
        <button class="btn" onclick="showSection('python')">Continuar â†’ AnÃ¡lisis Python</button>
    </section>

    <section id="python">
        <h2>ğŸ AnÃ¡lisis en Python: Cargando y Explorando</h2>
        <p>Python es como un "explorador curioso": lee el archivo y te cuenta todo. Usamos <code>defaultdict</code> para listas automÃ¡ticas y manejo robusto de errores.</p>

        <div class="codigo-correcto">
            <h4>âœ… CÃ³digo Python Corregido y Mejorado</h4>
        </div>

<div class="codigo-simple">
from collections import defaultdict
from typing import Dict, List, Tuple
import os

def load_graph(file_path: str, is_directed: bool = True) -> Dict[str, List[Tuple[str, float]]]:
    """
    Carga un grafo desde un archivo de texto con manejo robusto de errores.
    
    Args:
        file_path: Ruta al archivo de aristas
        is_directed: True para grafo dirigido, False para no dirigido
    
    Returns:
        Diccionario con lista de adyacencia
    """
    adjacency_list = defaultdict(list)
    
    if not os.path.exists(file_path):
        print(f"âŒ Error: El archivo '{file_path}' no existe.")
        return adjacency_list
    
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            for line_num, line in enumerate(file, 1):
                line = line.strip()
                
                # Ignorar lÃ­neas vacÃ­as y comentarios
                if not line or line.startswith('#'):
                    continue
                
                parts = line.split()
                if len(parts) < 2:
                    print(f"âš ï¸  LÃ­nea {line_num}: '{line}' ignorada (faltan vÃ©rtices)")
                    continue
                
                from_vertex, to_vertex = parts[0], parts[1]
                
                # Procesar peso con validaciÃ³n
                try:
                    weight = float(parts[2]) if len(parts) > 2 else 1.0
                except (ValueError, IndexError):
                    print(f"âš ï¸  LÃ­nea {line_num}: peso invÃ¡lido, usando 1.0")
                    weight = 1.0
                
                # Agregar arista
                adjacency_list[from_vertex].append((to_vertex, weight))
                
                # Si es no dirigido, agregar arista inversa
                if not is_directed:
                    adjacency_list[to_vertex].append((from_vertex, weight))
                    
    except FileNotFoundError:
        print(f"âŒ Error: No se encontrÃ³ el archivo '{file_path}'")
    except Exception as e:
        print(f"âŒ Error inesperado al leer '{file_path}': {e}")
    
    return dict(adjacency_list)

def get_neighbors(graph: Dict[str, List[Tuple[str, float]]], vertex: str) -> List[Tuple[str, float]]:
    """Obtiene la lista de vecinos de un vÃ©rtice."""
    return graph.get(vertex, [])

def has_edge(graph: Dict[str, List[Tuple[str, float]]], from_vertex: str, to_vertex: str) -> bool:
    """
    CORREGIDO: Verifica si existe una arista de from_vertex a to_vertex.
    Sintaxis corregida para desempaquetado de tuplas.
    """
    neighbors = graph.get(from_vertex, [])
    return any(neighbor == to_vertex for neighbor, _ in neighbors)

def get_out_degree(graph: Dict[str, List[Tuple[str, float]]], vertex: str) -> int:
    """Calcula el grado de salida de un vÃ©rtice."""
    return len(graph.get(vertex, []))

def get_in_degree(graph: Dict[str, List[Tuple[str, float]]], vertex: str) -> int:
    """Calcula el grado de entrada de un vÃ©rtice."""
    in_degree = 0
    for neighbors in graph.values():
        in_degree += sum(1 for neighbor, _ in neighbors if neighbor == vertex)
    return in_degree

def analyze_graph(graph: Dict[str, List[Tuple[str, float]]], graph_type: str):
    """Analiza y muestra estadÃ­sticas detalladas del grafo."""
    print(f"\n{'='*50}")
    print(f"ğŸ” AnÃ¡lisis del Grafo {graph_type}")
    print(f"{'='*50}")
    
    if not graph:
        print("âš ï¸  El grafo estÃ¡ vacÃ­o")
        return
    
    vertices = sorted(graph.keys())
    total_edges = sum(len(neighbors) for neighbors in graph.values())
    
    print(f"ğŸ“Š EstadÃ­sticas generales:")
    print(f"   â€¢ VÃ©rtices: {len(vertices)}")
    print(f"   â€¢ Aristas: {total_edges}")
    
    # Calcular densidad (para grafos dirigidos)
    max_possible_edges = len(vertices) * (len(vertices) - 1)
    if max_possible_edges > 0:
        density = total_edges / max_possible_edges
        print(f"   â€¢ Densidad: {density:.3f}")
    
    print(f"\nğŸ” Detalles por vÃ©rtice:")
    for vertex in vertices:
        out_deg = get_out_degree(graph, vertex)
        in_deg = get_in_degree(graph, vertex)
        neighbors = get_neighbors(graph, vertex)
        
        neighbor_str = ", ".join([f"{neighbor}({weight:.1f}km)" for neighbor, weight in neighbors])
        
        print(f"   {vertex}: Out-degree={out_deg}, In-degree={in_deg}")
        print(f"      â””â”€ Vecinos: [{neighbor_str}]")

def find_most_connected_vertex(graph: Dict[str, List[Tuple[str, float]]]) -> str:
    """Encuentra el vÃ©rtice con mayor grado total (entrada + salida)."""
    if not graph:
        return ""
    
    max_degree = 0
    most_connected = ""
    
    for vertex in graph.keys():
        total_degree = get_out_degree(graph, vertex) + get_in_degree(graph, vertex)
        if total_degree > max_degree:
            max_degree = total_degree
            most_connected = vertex
    
    return most_connected

# Programa principal
def main():
    """FunciÃ³n principal para anÃ¡lisis de grafos."""
    print("ğŸŒ === AnÃ¡lisis de Mapas de TrÃ¡fico - Proyecto Semana 3 ===")
    
    # Analizar grafo no dirigido
    undirected_graph = load_graph("edges_undirected.txt", is_directed=False)
    analyze_graph(undirected_graph, "No Dirigido")
    
    # Analizar grafo dirigido
    directed_graph = load_graph("edges_directed.txt", is_directed=True)
    analyze_graph(directed_graph, "Dirigido")
    
    # Pruebas de conectividad
    print(f"\n{'='*50}")
    print("ğŸ”— Pruebas de Conectividad")
    print(f"{'='*50}")
    
    if directed_graph:
        print(f"Â¿Aâ†’G dirigido? {has_edge(directed_graph, 'A', 'G')} (esperado: True)")
        print(f"Â¿Gâ†’A dirigido? {has_edge(directed_graph, 'G', 'A')} (esperado: False)")
        
        if 'A' in directed_graph:
            print(f"Grado de salida de A: {get_out_degree(directed_graph, 'A')}")
            print(f"Grado de entrada de A: {get_in_degree(directed_graph, 'A')}")
        
        # AnÃ¡lisis adicional
        most_connected = find_most_connected_vertex(directed_graph)
        if most_connected:
            print(f"VÃ©rtice mÃ¡s conectado: {most_connected}")
    
    print("\nğŸ‰ Â¡AnÃ¡lisis completado exitosamente!")

if __name__ == "__main__":
    main()
</div>

        <div class="actividad">
            <h4>ğŸ”§ Correcciones y Mejoras Aplicadas</h4>
            <ul>
                <li>âœ… <strong>Error sintÃ¡ctico corregido:</strong> <code>has_edge</code> ahora desempaqueta correctamente las tuplas</li>
                <li>âœ… <strong>Manejo robusto de errores:</strong> ValidaciÃ³n de archivos, lÃ­neas malformadas y pesos invÃ¡lidos</li>
                <li>âœ… <strong>Funciones adicionales:</strong> <code>get_in_degree()</code> y <code>find_most_connected_vertex()</code></li>
                <li>âœ… <strong>DocumentaciÃ³n mejorada:</strong> Docstrings claros y comentarios explicativos</li>
                <li>âœ… <strong>Salida formateada:</strong> Emojis y formato claro para mejor legibilidad</li>
                <li>âœ… <strong>AnÃ¡lisis avanzado:</strong> CÃ¡lculo de densidad y vÃ©rtice mÃ¡s conectado</li>
            </ul>
        </div>

        <div class="actividad">
            <h4>ğŸ§ª Ejemplo de Salida Esperada</h4>
            <pre style="background: #f8f9fa; color: #333; padding: 15px; border-left: 4px solid #28a745;">
ğŸŒ === AnÃ¡lisis de Mapas de TrÃ¡fico - Proyecto Semana 3 ===
âœ… Archivo 'edges_undirected.txt' cargado exitosamente.

==================================================
ğŸ” AnÃ¡lisis del Grafo No Dirigido
==================================================
ğŸ“Š EstadÃ­sticas generales:
   â€¢ VÃ©rtices: 8
   â€¢ Aristas: 14
   â€¢ Densidad: 0.250

ğŸ” Detalles por vÃ©rtice:
   A: Out-degree=2, In-degree=2
      â””â”€ Vecinos: [B(2.0km), C(3.0km)]
   B: Out-degree=2, In-degree=2
      â””â”€ Vecinos: [A(2.0km), D(1.0km)]
   ...
            </pre>
        </div>

        <div class="checkpoint">
            <h4>ğŸ”„ De ImplementaciÃ³n a AnÃ¡lisis</h4>
            <p>
                <strong>Ya tienes:</strong> CÃ³digo que funciona en ambos lenguajes<br>
                <strong>Ahora necesitas:</strong> Entender las implicaciones de tus decisiones de diseÃ±o<br>
                <strong>Pregunta clave:</strong> Â¿Fue buena idea usar listas de adyacencia? Â¡Vamos a analizarlo!
            </p>
        </div>
        
        <button class="btn" onclick="showSection('analisis')">Continuar â†’ AnÃ¡lisis Trade-offs</button>
    </section>

    <section id="analisis">
        <h2>âš–ï¸ AnÃ¡lisis de Trade-offs: Â¿Por QuÃ© AsÃ­?</h2>
        <p>Ahora que tenemos nuestro grafo funcionando, analicemos las decisiones tÃ©cnicas. Como buenos ingenieros, siempre debemos justificar nuestras elecciones.</p>

        <div class="actividad">
            <h4>ğŸ¤” La Gran Pregunta</h4>
            <p><strong>Â¿Por quÃ© elegimos listas de adyacencia en lugar de matriz de adyacencia?</strong></p>
            <p>La respuesta no es "porque sÃ­" â€“ hay razones tÃ©cnicas sÃ³lidas que veremos en la siguiente tabla.</p>
        </div>

        <table>
            <tr>
                <th>Criterio</th>
                <th>Lista de Adyacencia (Nuestra ElecciÃ³n)</th>
                <th>Matriz de Adyacencia (Alternativa)</th>
            </tr>
            <tr>
                <td><strong>Memoria para nuestro grafo</strong><br>(n=8, m=12)</td>
                <td style="background: #d4edda;">âœ… <strong>Excelente:</strong> O(20) elementos<br>Solo guarda conexiones reales</td>
                <td style="background: #f8d7da;">âŒ <strong>Desperdicio:</strong> O(64) elementos<br>Tabla 8Ã—8 completa, mayorÃ­a vacÃ­a</td>
            </tr>
            <tr>
                <td><strong>Â¿Existe arista uâ†’v?</strong></td>
                <td style="background: #fff3cd;">âš ï¸ <strong>Aceptable:</strong> O(grado de u)<br>~2-3 pasos para nuestro mapa</td>
                <td style="background: #d4edda;">âœ… <strong>InstantÃ¡neo:</strong> O(1)<br>Acceso directo matriz[u][v]</td>
            </tr>
            <tr>
                <td><strong>Recorrer vecinos de u</strong></td>
                <td style="background: #d4edda;">âœ… <strong>Eficiente:</strong> O(grado de u)<br>Solo toca vecinos reales</td>
                <td style="background: #f8d7da;">âŒ <strong>Lento:</strong> O(n=8)<br>Revisa toda la fila, incluso vacÃ­os</td>
            </tr>
            <tr>
                <td><strong>Agregar/eliminar arista</strong></td>
                <td style="background: #d4edda;">âœ… <strong>RÃ¡pido:</strong> O(1) agregar<br>O(grado) eliminar</td>
                <td style="background: #d4edda;">âœ… <strong>RÃ¡pido:</strong> O(1)<br>Ambas operaciones</td>
            </tr>
            <tr>
                <td><strong>Escenario ideal</strong></td>
                <td style="background: #d4edda;">ğŸŒ <strong>Mapas dispersos</strong><br>Ciudades reales, redes sociales</td>
                <td style="background: #fff3cd;">ğŸ”— <strong>Grafos densos</strong><br>Redes completas, pequeÃ±as</td>
            </tr>
        </table>

        <div class="mapa-mental">
            <h4>ğŸ§  ConclusiÃ³n TÃ©cnica</h4>
            <p><strong>Para nuestro proyecto:</strong> Lista de adyacencia es la elecciÃ³n correcta porque tenemos un grafo <em>disperso</em> (pocas conexiones por vÃ©rtice) y necesitamos eficiencia en recorridos (ideal para algoritmos futuros como BFS/DFS).</p>
        </div>

        <div class="grid">
            <div class="actividad">
                <h4>ğŸ“Š AnÃ¡lisis Cuantitativo</h4>
                <p><strong>Nuestro grafo especÃ­fico:</strong></p>
                <ul>
                    <li>Densidad â‰ˆ 0.25 (25% de conexiones posibles)</li>
                    <li>Grado promedio â‰ˆ 3 conexiones por vÃ©rtice</li>
                    <li>Memoria usada: ~20 elementos vs 64 en matriz</li>
                    <li><strong>Ahorro de memoria: 69%</strong></li>
                </ul>
            </div>
            <div class="actividad">
                <h4>ğŸ”® Escalabilidad Futura</h4>
                <p><strong>Si nuestro mapa crece:</strong></p>
                <ul>
                    <li>100 intersecciones â†’ Lista: O(300), Matriz: O(10,000)</li>
                    <li>1000 intersecciones â†’ Lista: O(3,000), Matriz: O(1,000,000)</li>
                    <li><strong>La diferencia se vuelve dramÃ¡tica</strong></li>
                </ul>
            </div>
        </div>

        <div class="reflexion">
            <h4>ğŸ’­ Pregunta de ReflexiÃ³n</h4>
            <p><strong>Â¿CuÃ¡ndo elegirÃ­as matriz de adyacencia?</strong></p>
            <details>
                <summary>ğŸ’¡ Ver respuesta</summary>
                <div style="margin-top: 10px; padding: 15px; background: #f0f8ff; border-radius: 5px;">
                    <p><strong>Matriz serÃ­a mejor cuando:</strong></p>
                    <ul>
                        <li>Grafo muy denso (>50% de conexiones posibles)</li>
                        <li>Consultas frecuentes de "Â¿existe arista Xâ†’Y?"</li>
                        <li>Operaciones matriciales (multiplicaciÃ³n, potencias)</li>
                        <li>Grafos pequeÃ±os donde la memoria no importa</li>
                    </ul>
                    <p><em>Ejemplo:</em> Red de vuelos directos entre 10 ciudades principales (muchas conexiones).</p>
                </div>
            </details>
        </div>
        
        <button class="btn" onclick="showSection('evaluacion')">Continuar â†’ Criterios de EvaluaciÃ³n</button>
    </section>

    <section id="evaluacion">
        <h2>ğŸ“Š Criterios de EvaluaciÃ³n y Entregables</h2>
        <p>Ahora que tienen el cÃ³digo funcionando, veamos exactamente quÃ© necesitan entregar y cÃ³mo serÃ¡ evaluado su proyecto.</p>

        <div class="evaluacion">
            <h3>ğŸ“‹ Entregables Requeridos</h3>
            <div class="grid">
                <div>
                    <h4>ğŸ’» Archivos de CÃ³digo</h4>
                    <ul>
                        <li>âœ… <code>Graph.cs</code> - Clase genÃ©rica funcional</li>
                        <li>âœ… <code>Program.cs</code> - Programa principal que genera archivos</li>
                        <li>âœ… <code>analysis.py</code> - Script de anÃ¡lisis completo</li>
                    </ul>
                </div>
                <div>
                    <h4>ğŸ“„ Archivos de Datos</h4>
                    <ul>
                        <li>âœ… <code>edges_undirected.txt</code> - 7 aristas bidireccionales</li>
                        <li>âœ… <code>edges_directed.txt</code> - 17 aristas totales</li>
                        <li>âœ… Ambos con formato: <code>origen destino peso</code></li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="actividad">
            <h3>ğŸ“– Reporte TÃ©cnico (2-3 pÃ¡ginas PDF)</h3>
            <h4><strong>SecciÃ³n 1: DiseÃ±o del Modelo (25% - 25 puntos)</strong></h4>
            <ul>
                <li><strong>DescripciÃ³n del mapa:</strong> Â¿QuÃ© representa cada vÃ©rtice? Â¿Por quÃ© elegiste esas conexiones?</li>
                <li><strong>JustificaciÃ³n de aristas:</strong> Â¿Por quÃ© algunas son bidireccionales y otras no?</li>
                <li><strong>Criterio de pesos:</strong> Â¿CÃ³mo asignaste las distancias? Â¿Son realistas?</li>
                <li><strong>Diagrama:</strong> Incluye tu dibujo del mapa con etiquetas claras</li>
            </ul>

            <h4><strong>SecciÃ³n 2: Decisiones de ImplementaciÃ³n (40% - 40 puntos)</strong></h4>
            <ul>
                <li><strong>Lista vs Matriz:</strong> Â¿Por quÃ© elegiste listas de adyacencia? AnÃ¡lisis con nÃºmeros concretos</li>
                <li><strong>Manejo de direccionalidad:</strong> Â¿CÃ³mo tu cÃ³digo diferencia dirigido vs no dirigido?</li>
                <li><strong>Trade-offs identificados:</strong> Â¿QuÃ© perdiste y quÃ© ganaste con tu elecciÃ³n?</li>
                <li><strong>Escalabilidad:</strong> Â¿CÃ³mo se comportarÃ­a tu soluciÃ³n con 100+ vÃ©rtices?</li>
            </ul>

            <h4><strong>SecciÃ³n 3: Resultados y ValidaciÃ³n (25% - 25 puntos)</strong></h4>
            <ul>
                <li><strong>Screenshots de ejecuciÃ³n:</strong> Salida de ambos programas</li>
                <li><strong>VerificaciÃ³n manual:</strong> Comprueba 2-3 cÃ¡lculos de grado a mano</li>
                <li><strong>Casos de prueba:</strong> Â¿QuÃ© aristas probaste que existen/no existen?</li>
            </ul>

            <h4><strong>SecciÃ³n 4: ReflexiÃ³n Personal (10% - 10 puntos)</strong></h4>
            <ul>
                <li>Â¿QuÃ© fue lo mÃ¡s desafiante del proyecto?</li>
                <li>Â¿CÃ³mo aplicarÃ­as grafos en un problema real de tu interÃ©s?</li>
                <li>Â¿QuÃ© cambiarÃ­as en tu implementaciÃ³n si empezaras de nuevo?</li>
            </ul>
        </div>

        <table style="margin-top: 20px;">
            <tr><th>Criterio</th><th>Excelente (90-100)</th><th>Bueno (80-89)</th><th>Satisfactorio (70-79)</th><th>Insuficiente (&lt;70)</th></tr>
            <tr>
                <td><strong>CÃ³digo</strong></td>
                <td>Limpio, comentado, sin errores, extensiones implementadas</td>
                <td>Funcional, comentarios bÃ¡sicos, requisitos cumplidos</td>
                <td>Funciona con errores menores, documentaciÃ³n mÃ­nima</td>
                <td>No compila o errores mayores</td>
            </tr>
            <tr>
                <td><strong>AnÃ¡lisis</strong></td>
                <td>Profundo, con nÃºmeros, insights originales</td>
                <td>Correcto, ejemplos concretos, razonamiento sÃ³lido</td>
                <td>BÃ¡sico pero correcto, anÃ¡lisis superficial</td>
                <td>Incorrecto o faltante</td>
            </tr>
            <tr>
                <td><strong>Reporte</strong></td>
                <td>Profesional, bien estructurado, diagrama claro</td>
                <td>Claro, secciones completas, buena presentaciÃ³n</td>
                <td>InformaciÃ³n bÃ¡sica, estructura aceptable</td>
                <td>Incompleto o confuso</td>
            </tr>
        </table>

        <div class="checkpoint">
            <h4>âš ï¸ Errores Comunes a Evitar</h4>
            <ul>
                <li>âŒ No manejar archivos inexistentes en Python</li>
                <li>âŒ Duplicar aristas en exportaciÃ³n de grafos no dirigidos</li>
                <li>âŒ Confundir grado de entrada vs salida</li>
                <li>âŒ AnÃ¡lisis superficial sin nÃºmeros concretos</li>
                <li>âŒ Reporte sin diagrama o screenshots</li>
            </ul>
        </div>

        <div class="actividad">
            <h4>ğŸ“¦ Formato de Entrega</h4>
            <p><strong>Archivo ZIP:</strong> <code>ProyectoS3_[Apellido]_[Nombre].zip</code></p>
            <p><strong>Contenido del ZIP:</strong></p>
            <ul>
                <li><code>codigo/</code> - Carpeta con todos los archivos .cs y .py</li>
                <li><code>datos/</code> - Carpeta con archivos .txt generados</li>
                <li><code>Reporte_[Apellido].pdf</code> - Tu reporte tÃ©cnico</li>
                <li><code>README.txt</code> - Instrucciones para ejecutar tu cÃ³digo</li>
            </ul>
            <p><strong>Fecha lÃ­mite:</strong> [Especificar fecha segÃºn calendario acadÃ©mico]</p>
        </div>
        
        <button class="btn" onclick="showSection('diferenciacion')">Ver Niveles de Dificultad â†’</button>
    </section>

    <section id="diferenciacion">
        <h2>ğŸ¯ Actividades Diferenciadas por Nivel</h2>
        <p>Reconocemos que cada estudiante tiene diferentes fortalezas y experiencia previa. AquÃ­ hay opciones adaptadas a distintos niveles de comodidad con la programaciÃ³n.</p>

        <div class="actividad nivel-basico">
            <h3>ğŸŸ¢ Nivel BÃ¡sico - "Empezando con Confianza"</h3>
            <h4>Para estudiantes que se sienten menos cÃ³modos con programaciÃ³n</h4>
            
            <div class="grid">
                <div>
                    <h4>ğŸ“ Simplificaciones Aplicadas</h4>
                    <ul>
                        <li><strong>Grafo mÃ¡s pequeÃ±o:</strong> 5-6 vÃ©rtices en lugar de 8</li>
                        <li><strong>Solo no dirigido:</strong> Evitar confusiÃ³n con direcciones</li>
                        <li><strong>Pesos enteros:</strong> Usar 1, 2, 3 en lugar de decimales</li>
                        <li><strong>Plantilla proporcionada:</strong> CÃ³digo base pre-escrito</li>
                    </ul>
                </div>
                <div>
                    <h4>ğŸ¤ Apoyo Adicional</h4>
                    <ul>
                        <li><strong>TutorÃ­as programadas:</strong> Sesiones extra de ayuda</li>
                        <li><strong>Pair programming:</strong> Trabajar con compaÃ±ero mÃ¡s avanzado</li>
                        <li><strong>Checklist detallado:</strong> Pasos especÃ­ficos a seguir</li>
                        <li><strong>Ejemplos trabajados:</strong> Casos paso a paso</li>
                    </ul>
                </div>
            </div>

            <div class="actividad">
                <h4>âœï¸ Actividad de Refuerzo</h4>
                <p><strong>Tracing Manual:</strong> Antes de programar, ejecuta en papel:</p>
                <ol>
                    <li>Dibuja un grafo de 4 vÃ©rtices: A, B, C, D</li>
                    <li>Agrega aristas: A-B (peso 2), B-C (peso 1), A-D (peso 3)</li>
                    <li>Simula <code>AddEdge("A", "B", 2, false)</code> paso a paso</li>
                    <li>Calcula manualmente el grado de cada vÃ©rtice</li>
                </ol>
            </div>
        </div>

        <div class="actividad nivel-intermedio">
            <h3>ğŸŸ¡ Nivel Intermedio - "Proyecto EstÃ¡ndar"</h3>
            <h4>Para la mayorÃ­a de estudiantes con conocimientos bÃ¡sicos sÃ³lidos</h4>
            
            <p><strong>MantÃ©n el proyecto como estÃ¡ especificado:</strong></p>
            <ul>
                <li>âœ… 8 vÃ©rtices con mezcla dirigido/no dirigido</li>
                <li>âœ… ImplementaciÃ³n en C# y Python</li>
                <li>âœ… AnÃ¡lisis de trade-offs completo</li>
                <li>âœ… Reporte tÃ©cnico de 2-3 pÃ¡ginas</li>
            </ul>

            <div class="actividad">
                <h4>ğŸ’¡ Consejos para el Ã‰xito</h4>
                <ul>
                    <li><strong>Empieza temprano:</strong> No dejes todo para el Ãºltimo dÃ­a</li>
                    <li><strong>Prueba frecuentemente:</strong> Verifica cada funciÃ³n antes de continuar</li>
                    <li><strong>Documenta mientras codificas:</strong> Anota decisiones importantes</li>
                    <li><strong>Busca ayuda cuando la necesites:</strong> Oficinas de horario, foros, compaÃ±eros</li>
                </ul>
            </div>
        </div>

        <div class="actividad nivel-avanzado">
            <h3>ğŸ”´ Nivel Avanzado - "DesafÃ­os Adicionales"</h3>
            <h4>Para estudiantes que buscan ir mÃ¡s allÃ¡</h4>
            
            <div class="grid">
                <div>
                    <h4>ğŸš€ Extensiones TÃ©cnicas</h4>
                    <ul>
                        <li><strong>Algoritmos adicionales:</strong>
                            <br><code>FindShortestPath(start, end)</code> con BFS</li>
                        <li><strong>DetecciÃ³n de ciclos:</strong>
                            <br><code>HasCycles()</code> para grafos dirigidos</li>
                        <li><strong>AnÃ¡lisis de centralidad:</strong>
                            <br>Encuentra vÃ©rtices mÃ¡s "importantes"</li>
                        <li><strong>Persistencia avanzada:</strong>
                            <br>Carga/guarda en JSON o XML</li>
                    </ul>
                </div>
                <div>
                    <h4>ğŸ“Š AnÃ¡lisis Profundo</h4>
                    <ul>
                        <li><strong>VisualizaciÃ³n:</strong> Generar archivo .dot para Graphviz</li>
                        <li><strong>MÃ©tricas avanzadas:</strong> DiÃ¡metro, excentricidad</li>
                        <li><strong>ComparaciÃ³n empÃ­rica:</strong> Medir tiempos de ejecuciÃ³n</li>
                        <li><strong>Optimizaciones:</strong> Implementar con diferentes estructuras</li>
                    </ul>
                </div>
            </div>

            <div class="codigo-correcto">
                <h4>ğŸ’» Ejemplo de ExtensiÃ³n: DetecciÃ³n de Ciclos</h4>
                <pre><code><span style="color: #3498db;">public</span> <span style="color: #3498db;">bool</span> HasCycles()
{
    <span style="color: #3498db;">var</span> visited = <span style="color: #3498db;">new</span> HashSet&lt;T&gt;();
    <span style="color: #3498db;">var</span> recursionStack = <span style="color: #3498db;">new</span> HashSet&lt;T&gt;();
    
    <span style="color: #3498db;">foreach</span> (<span style="color: #3498db;">var</span> vertex <span style="color: #3498db;">in</span> GetVertices())
    {
        <span style="color: #3498db;">if</span> (!visited.Contains(vertex))
        {
            <span style="color: #3498db;">if</span> (HasCycleDFS(vertex, visited, recursionStack))
                <span style="color: #3498db;">return</span> <span style="color: #3498db;">true</span>;
        }
    }
    <span style="color: #3498db;">return</span> <span style="color: #3498db;">false</span>;
}</code></pre>
            </div>

            <div class="actividad">
                <h4>ğŸ† Criterios de EvaluaciÃ³n Avanzada</h4>
                <p><strong>Para obtener calificaciÃ³n sobresaliente (95-100):</strong></p>
                <ul>
                    <li>Implementar al menos 2 extensiones adicionales</li>
                    <li>AnÃ¡lisis comparativo con mÃ©tricas de rendimiento</li>
                    <li>Reporte extendido (4-5 pÃ¡ginas) con secciÃ³n de optimizaciones</li>
                    <li>CÃ³digo bien documentado con ejemplos de uso</li>
                </ul>
            </div>
        </div>

        <div class="mapa-mental">
            <h4>ğŸ¯ ElecciÃ³n de Nivel</h4>
            <p><strong>Recuerda:</strong> El objetivo es aprender, no impresionar. Elige el nivel donde te sientes desafiado pero no abrumado. Siempre puedes hacer extensiones despuÃ©s de completar los requisitos bÃ¡sicos.</p>
        </div>
        
        <button class="btn" onclick="showSection('reflexion')">Continuar â†’ ReflexiÃ³n Final</button>
    </section>

    <section id="reflexion">
        <div class="reflexion">
            <h2>ğŸ­ ReflexiÃ³n Final: Â¡Piensen en Voz Alta!</h2>
            
            <div class="grid">
                <div class="actividad">
                    <h4>ğŸ’­ Preguntas de ReflexiÃ³n Individual</h4>
                    <ol>
                        <li><strong>Trade-offs tÃ©cnicos:</strong> Â¿QuÃ© pasarÃ­a si cambiaras de lista a matriz en tu mapa especÃ­fico? Â¿CuÃ¡nta memoria adicional necesitarÃ­as?</li>
                        <li><strong>Escalabilidad:</strong> Si tu ciudad creciera a 1000 intersecciones, Â¿seguirÃ­as usando la misma representaciÃ³n?</li>
                        <li><strong>Simplicidad vs funcionalidad:</strong> Â¿CÃ³mo cambiarÃ­a el diseÃ±o si no necesitaras pesos en las aristas?</li>
                        <li><strong>Extensiones futuras:</strong> Â¿QuÃ© funcionalidad agregarÃ­as para la prÃ³xima semana cuando veamos algoritmos de bÃºsqueda?</li>
                    </ol>
                </div>
                
                <div class="actividad">
                    <h4>ğŸ‘¥ DiscusiÃ³n en Parejas (10 min)</h4>
                    <p><strong>Intercambien ideas sobre:</strong></p>
                    <ul>
                        <li>Â¿CuÃ¡l fue la parte mÃ¡s desafiante del proyecto?</li>
                        <li>Â¿En quÃ© otros problemas reales usarÃ­an grafos?</li>
                        <li>Â¿QuÃ© harÃ­an diferente si empezaran de nuevo?</li>
                        <li>Â¿CÃ³mo conecta esto con lo que vieron en semanas anteriores?</li>
                    </ul>
                </div>
            </div>

            <div class="checkpoint">
                <h4>ğŸ§  Conexiones Conceptuales</h4>
                <p><strong>Este proyecto conecta con:</strong></p>
                <ul>
                    <li><strong>Semana 1-2:</strong> Estructuras de datos bÃ¡sicas (listas, diccionarios) que usamos en la implementaciÃ³n</li>
                    <li><strong>Semana 4:</strong> Algoritmos BFS/DFS se construirÃ¡n sobre esta base de grafos</li>
                    <li><strong>Semana 5:</strong> Algoritmos de caminos mÃ­nimos usarÃ¡n los pesos que implementamos</li>
                    <li><strong>Proyecto final:</strong> Esta serÃ¡ la base para el sistema de navegaciÃ³n completo</li>
                </ul>
            </div>

            <div class="actividad">
                <h4>ğŸ“ AutoevaluaciÃ³n Honesta</h4>
                <p><strong>Antes de entregar, pregÃºntate:</strong></p>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <p>âœ… <strong>Â¿Mi cÃ³digo compila y ejecuta sin errores?</strong></p>
                    <p>âœ… <strong>Â¿ProbÃ© casos extremos? (archivos inexistentes, vÃ©rtices sin conexiones)</strong></p>
                    <p>âœ… <strong>Â¿Mi anÃ¡lisis incluye nÃºmeros concretos y no solo teorÃ­a?</strong></p>
                    <p>âœ… <strong>Â¿JustifiquÃ© tÃ©cnicamente mis decisiones de diseÃ±o?</strong></p>
                    <p>âœ… <strong>Â¿Mi reporte es profesional y estÃ¡ bien estructurado?</strong></p>
                </div>
            </div>

            <div class="mapa-mental">
                <h4>ğŸ‰ Â¡Felicitaciones!</h4>
                <p>Has completado un proyecto complejo que combina teorÃ­a de grafos, programaciÃ³n en mÃºltiples lenguajes, y anÃ¡lisis tÃ©cnico. Estas habilidades son fundamentales en ciencias de la computaciÃ³n y te servirÃ¡n en tu carrera profesional.</p>
            </div>

            <div class="actividad">
                <h4>ğŸ”— Recursos Adicionales</h4>
                <ul>
                    <li><strong>VisualizaciÃ³n de grafos:</strong> <a href="https://graphviz.org/" target="_blank">Graphviz</a> para crear diagramas automÃ¡ticamente</li>
                    <li><strong>Lecturas complementarias:</strong> "Introduction to Algorithms" (Cormen) - CapÃ­tulo 22</li>
                    <li><strong>Aplicaciones reales:</strong> Estudiar cÃ³mo Google Maps implementa algoritmos de grafos</li>
                    <li><strong>PrÃ¡ctica adicional:</strong> LeetCode - problemas etiquetados como "Graph"</li>
                </ul>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <p><strong>Â¡Excelente trabajo! Entreguen su cÃ³digo y reporte.</strong></p>
                <p>Si tienen dudas, pregunten en clase o en horarios de oficina.</p>
                
                <div style="margin: 20px 0;">
                    <button class="btn btn-success" onclick="resetProject()">ğŸ”„ Recomenzar Proyecto</button>
                    <button class="btn" onclick="showSection('intro')">ğŸ“š Volver al Inicio</button>
                </div>
                
                <p style="font-size: 0.9em; color: #666; margin-top: 20px;">
                    <em>Proyecto desarrollado para Estructuras de Datos Avanzadas â€¢ VersiÃ³n 2025</em>
                </p>
            </div>
        </div>
    </section>

    <script>
        // Variables globales para navegaciÃ³n
        let currentSection = 'intro';
        const sections = ['intro', 'objetivos', 'diseno', 'csharp', 'python', 'analisis', 'evaluacion', 'diferenciacion', 'reflexion'];

        // FunciÃ³n principal para mostrar secciones
        function showSection(sectionId) {
            // Ocultar todas las secciones
            document.querySelectorAll('section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Mostrar la secciÃ³n seleccionada
            const targetSection = document.getElementById(sectionId);
            if (targetSection) {
                targetSection.classList.add('active');
                currentSection = sectionId;
            }
            
            // Actualizar botones de navegaciÃ³n
            updateNavigationButtons(sectionId);
            
            // Scroll suave al inicio
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Actualizar estados de botones de navegaciÃ³n
        function updateNavigationButtons(activeSection) {
            document.querySelectorAll('.nav-btn').forEach(button => {
                button.classList.remove('active');
            });
            
            // Encontrar y activar el botÃ³n correspondiente
            const activeButton = document.querySelector(`[onclick="showSection('${activeSection}')"]`);
            if (activeButton) {
                activeButton.classList.add('active');
            }
        }

        // FunciÃ³n para reiniciar el proyecto
        function resetProject() {
            showSection('intro');
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // NavegaciÃ³n con teclado
        document.addEventListener('keydown', function(event) {
            const currentIndex = sections.indexOf(currentSection);
            
            if (event.key === 'ArrowRight' && currentIndex < sections.length - 1) {
                showSection(sections[currentIndex + 1]);
            } else if (event.key === 'ArrowLeft' && currentIndex > 0) {
                showSection(sections[currentIndex - 1]);
            }
        });

        // Funcionalidad para details/summary (expandir/contraer)
        document.addEventListener('DOMContentLoaded', function() {
            // Asegurar que la primera secciÃ³n estÃ© activa
            showSection('intro');
            
            // Mejorar accesibilidad de los details
            document.querySelectorAll('details').forEach(detail => {
                detail.addEventListener('toggle', function() {
                    if (this.open) {
                        // Scroll suave para ver el contenido expandido
                        setTimeout(() => {
                            this.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        }, 100);
                    }
                });
            });
        });

        // Easter egg para estudiantes curiosos
        let keySequence = [];
        const konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA'];
        
        document.addEventListener('keydown', function(event) {
            keySequence.push(event.code);
            
            if (keySequence.length > konamiCode.length) {
                keySequence.shift();
            }
            
            if (keySequence.join(',') === konamiCode.join(',')) {
                alert('ğŸ® Â¡Easter Egg encontrado! \n\nTip de Grafos: La elecciÃ³n entre lista y matriz depende de la densidad. \n\nğŸ“Š Regla prÃ¡ctica:\nâ€¢ Lista: si aristas < vÃ©rticesÂ²/2\nâ€¢ Matriz: si aristas > vÃ©rticesÂ²/2\n\nÂ¡Sigue explorando!');
                keySequence = [];
            }
        });

        // Progreso visual (opcional)
        function updateProgress() {
            const currentIndex = sections.indexOf(currentSection);
            const progress = ((currentIndex + 1) / sections.length) * 100;
            
            // Si existe una barra de progreso, actualizarla
            const progressBar = document.querySelector('.progress-fill');
            if (progressBar) {
                progressBar.style.width = progress + '%';
            }
        }

        // Llamar a updateProgress cuando cambie de secciÃ³n
        const originalShowSection = showSection;
        showSection = function(sectionId) {
            originalShowSection(sectionId);
            updateProgress();
        };

        // Funcionalidad adicional: marcar completado
        function markAsCompleted(sectionId) {
            const button = document.querySelector(`[onclick="showSection('${sectionId}')"]`);
            if (button && !button.classList.contains('completed')) {
                button.classList.add('completed');
                button.innerHTML += ' âœ…';
            }
        }

        // Auto-marcar secciones como completadas despuÃ©s de cierto tiempo
        let sectionTimers = {};
        
        function startSectionTimer(sectionId) {
            if (sectionTimers[sectionId]) {
                clearTimeout(sectionTimers[sectionId]);
            }
            
            sectionTimers[sectionId] = setTimeout(() => {
                markAsCompleted(sectionId);
            }, 60000); // Marcar como completado despuÃ©s de 1 minuto
        }

        // Integrar timer con showSection
        const originalShowSectionWithTimer = showSection;
        showSection = function(sectionId) {
            originalShowSectionWithTimer(sectionId);
            startSectionTimer(sectionId);
        };
    </script>

</body>
</html>