<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° Semana 6 ‚Äì Algoritmos de Optimizaci√≥n en Grafos Ponderados</title>
    <style>
        /* Reset y configuraci√≥n base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            padding: 20px;
            background-color: #f9f9f9;
            color: #333;
        }

        /* Contenedor principal */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        /* Tipograf√≠a */
        h1 {
            text-align: center;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        h2 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin: 40px 0 20px 0;
        }

        h3 {
            color: #2c3e50;
            border-bottom: 1px solid #bdc3c7;
            padding-bottom: 8px;
            margin: 25px 0 15px 0;
        }

        h4 {
            color: #34495e;
            margin: 20px 0 10px 0;
        }

        p {
            margin-bottom: 15px;
        }

        /* Navegaci√≥n */
        nav ul {
            list-style: none;
            display: flex;
            justify-content: space-around;
            background: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        nav li {
            margin: 5px 10px;
        }

        nav a {
            text-decoration: none;
            color: #2c3e50;
            font-weight: 500;
            transition: color 0.3s;
        }

        nav a:hover {
            color: #3498db;
        }

        /* Secciones especiales */
        .section {
            margin-bottom: 40px;
        }

        .objectives {
            background: #e8f4fd;
            padding: 20px;
            border-left: 5px solid #3498db;
            border-radius: 5px;
            margin: 20px 0;
        }

        .concepts {
            background: #fff3cd;
            padding: 20px;
            border-left: 5px solid #ffc107;
            border-radius: 5px;
            margin: 20px 0;
        }

        .visualization {
            background: #e8f8f5;
            padding: 20px;
            border-left: 5px solid #1abc9c;
            border-radius: 5px;
            margin: 20px 0;
        }

        .comparison {
            background: #fef5e7;
            padding: 20px;
            border-left: 5px solid #f39c12;
            border-radius: 5px;
            margin: 20px 0;
        }

        .application {
            background: #ebf5fb;
            padding: 20px;
            border-left: 5px solid #5dade2;
            border-radius: 5px;
            margin: 20px 0;
        }

        .complexity {
            background: #ffe6e6;
            padding: 20px;
            border-left: 5px solid #e74c3c;
            border-radius: 5px;
            margin: 20px 0;
        }

        .checklist {
            background: #d4edda;
            padding: 20px;
            border-left: 5px solid #28a745;
            border-radius: 5px;
            margin: 20px 0;
        }

        .warning {
            background: #f8d7da;
            padding: 20px;
            border-left: 5px solid #dc3545;
            border-radius: 5px;
            margin: 20px 0;
        }

        .project {
            background: #d1ecf1;
            padding: 20px;
            border-left: 5px solid #17a2b8;
            border-radius: 5px;
            margin: 20px 0;
        }

        .ia-activity {
            background: #e7d4f7;
            padding: 20px;
            border-left: 5px solid #9b59b6;
            border-radius: 5px;
            margin: 20px 0;
        }

        /* Tablas */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        th {
            background-color: #3498db;
            color: white;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        /* Listas */
        ul, ol {
            padding-left: 30px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        /* C√≥digo */
        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            color: #e74c3c;
        }

        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            line-height: 1.5;
        }

        pre code {
            background: none;
            color: inherit;
            padding: 0;
        }

        /* Enlaces */
        a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.3s;
        }

        a:hover {
            color: #2980b9;
            text-decoration: underline;
        }

        /* Footer */
        footer {
            margin-top: 60px;
            padding-top: 30px;
            border-top: 3px solid #3498db;
            text-align: center;
            color: #7f8c8d;
        }

        /* Elementos especiales */
        .prompt-number {
            background: #9b59b6;
            color: white;
            padding: 6px 12px;
            border-radius: 50%;
            font-weight: bold;
            margin-right: 10px;
            display: inline-block;
        }

        .ia-prompt {
            background: #f8f9fa;
            padding: 15px;
            border: 2px dashed #9b59b6;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
        }

        strong {
            color: #2c3e50;
        }

        em {
            color: #555;
        }

        /* Checkpoint */
        .checkpoint {
            background: #fffbea;
            padding: 25px;
            border: 3px dashed #f39c12;
            border-radius: 10px;
            margin: 30px 0;
        }

        /* Responsividad */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            nav ul {
                flex-direction: column;
                align-items: center;
            }

            table {
                font-size: 0.9em;
            }

            h1 {
                font-size: 1.5em;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({ startOnLoad: true, theme: 'default' });</script>
</head>
<body>
    <div class="container">
        <h1>‚ö° Semana 6 ‚Äì Algoritmos de Optimizaci√≥n en Grafos Ponderados</h1>
        
        <p><em>Estructuras de Datos Avanzadas ¬© 2025 | Versi√≥n Mejorada con Actividades IA</em></p>
        
        <nav>
            <ul>
                <li><a href="#intro">Introducci√≥n</a></li>
                <li><a href="#problem">Problema</a></li>
                <li><a href="#dijkstra">Dijkstra</a></li>
                <li><a href="#floyd">Floyd-Warshall</a></li>
                <li><a href="#comparison">Comparaci√≥n</a></li>
                <li><a href="#solution-py">C√≥digo Python</a></li>
                <li><a href="#applications">Aplicaciones</a></li>
                <li><a href="#test-cases">Casos de Prueba</a></li>
                <li><a href="#ia-activities">Actividades IA</a></li>
                <li><a href="#project">Proyecto</a></li>
            </ul>
        </nav>

        <!-- INTRODUCCI√ìN -->
        <section id="intro" class="section">
            <h2>üéØ Objetivos de la Semana</h2>
            <div class="objectives">
                <h3>¬øQu√© lograr√°s hoy?</h3>
                <ul>
                    <li>Entender el <strong>problema de caminos m√°s cortos</strong> en grafos ponderados y sus aplicaciones en GPS, redes y log√≠stica.</li>
                    <li>Implementar y analizar el <strong>Algoritmo de Dijkstra</strong> para caminos desde un origen √∫nico.</li>
                    <li>Dominar el <strong>Algoritmo de Floyd-Warshall</strong> para caminos entre todos los pares de nodos.</li>
                    <li>Implementar ambos en <strong>Python</strong> con optimizaciones para grafos densos y dispersos.</li>
                    <li>Comparar criterios de selecci√≥n: ¬øDijkstra o Floyd-Warshall? Seg√∫n densidad y requisitos.</li>
                    <li>Aplicar a problemas reales: enrutamiento de paquetes IP, planificaci√≥n de rutas urbanas, optimizaci√≥n de cadenas de suministro.</li>
                    <li>Desarrollar habilidades en uso de IA para depuraci√≥n y optimizaci√≥n de algoritmos de grafos.</li>
                </ul>
            </div>
            <div class="concepts">
                <h3>Enfoque Pedag√≥gico</h3>
                <p><strong>Flujo de Aprendizaje:</strong> Fundamentos Te√≥ricos ‚Üí Visualizaci√≥n Paso a Paso ‚Üí Implementaci√≥n en Python ‚Üí Aplicaciones Pr√°cticas ‚Üí An√°lisis Comparativo ‚Üí Potenciaci√≥n con IA.</p>
                <p><em>üí° Filosof√≠a: "En un mundo conectado, los caminos m√°s cortos no son solo matem√°ticas; son el n√∫cleo de la eficiencia global. Domina Dijkstra y Floyd-Warshall para optimizar lo invisible."</em></p>
                <p><strong>Conexi√≥n con Semanas Previas:</strong> Extiende BFS (Semana 5) a grafos ponderados. Usa grafos validados en Semana 4 para pruebas reales.</p>
            </div>
            <p><a href="#problem">Continuar ‚Üí Problema de Caminos</a></p>
        </section>

        <!-- PROBLEMA DE CAMINOS M√ÅS CORTOS -->
        <section id="problem" class="section">
            <h2>üõ£Ô∏è 2.3.1. Problema de Caminos M√°s Cortos: Desde GPS hasta Protocolos de Red</h2>
            
            <h3>Concepto Fundamental</h3>
            <p><span class="emoji">üü°</span> En grafos <em>ponderados</em>, las aristas tienen <strong>pesos</strong> (costos, distancias, tiempos). El <strong>problema de caminos m√°s cortos</strong> busca la ruta de menor costo total entre nodos, no solo el menor n√∫mero de aristas (como en BFS).</p>
            
            <div class="concepts">
                <h4>Caracter√≠sticas Clave</h4>
                <ul>
                    <li><strong>Tipos de Pesos:</strong> Positivos (distancias), negativos (deudas en finanzas), cero (conexiones gratuitas)</li>
                    <li><strong>Variantes del Problema:</strong>
                        <ul>
                            <li><strong>Un origen √∫nico:</strong> Camino desde s a todos (Dijkstra)</li>
                            <li><strong>Todos los pares:</strong> Matriz de distancias (Floyd-Warshall)</li>
                            <li><strong>Con restricciones:</strong> Evitar nodos espec√≠ficos, maximizar flujo</li>
                        </ul>
                    </li>
                    <li><strong>Complejidad Te√≥rica:</strong> O(V¬≤) para Floyd-Warshall; O((V+E) log V) para Dijkstra con heap</li>
                    <li><strong>Restricciones Comunes:</strong> No pesos negativos (Dijkstra); s√≠ negativos pero sin ciclos negativos (Bellman-Ford, Semana 7)</li>
                </ul>
            </div>

            <h3>Algoritmo General Paso a Paso</h3>
            <ol>
                <li><strong>Modelado:</strong> Representa el grafo con matriz de adyacencia o lista de adyacencia + pesos</li>
                <li><strong>Inicializaci√≥n:</strong> Distancia[origen] = 0; Distancia[otros] = ‚àû</li>
                <li><strong>Relajaci√≥n:</strong> Actualiza distancias iterativamente: Dist[u] + Peso(u,v) < Dist[v] ‚Üí Dist[v] = Dist[u] + Peso(u,v)</li>
                <li><strong>Finalizaci√≥n:</strong> Cuando no hay actualizaciones, las distancias son √≥ptimas</li>
            </ol>

            <div class="visualization">
                <h4>üé® Visualizaci√≥n del Problema</h4>
                <p>Grafo ponderado de ejemplo: Red de ciudades con distancias en km</p>
                
                <div class="mermaid" data-alt="Grafo ponderado con nodos A-F y pesos en aristas">
                graph TD
                    A((A<br/>0)) ---|10| B((B<br/>‚àû))
                    A ---|5| C((C<br/>‚àû))
                    B ---|3| D((D<br/>‚àû))
                    C ---|2| D
                    C ---|8| E((E<br/>‚àû))
                    D ---|4| E
                    B ---|15| F((F<br/>‚àû))
                    E ---|7| F
                    
                    style A fill:#e74c3c,stroke:#c0392b,stroke-width:4px,color:#fff
                    classDef inf fill:#95a5a6,stroke:#7f8c8d
                    class B,C,D,E,F inf
                </div>
                
                <p><strong>Objetivo:</strong> Calcular distancias m√≠nimas desde A a todos.</p>
                <table>
                    <tr>
                        <th>Nodo</th>
                        <th>Distancia Inicial</th>
                        <th>Camino √ìptimo Final</th>
                        <th>Distancia Final</th>
                    </tr>
                    <tr>
                        <td>A</td>
                        <td>0</td>
                        <td>A</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td>B</td>
                        <td>‚àû</td>
                        <td>A ‚Üí B</td>
                        <td>10</td>
                    </tr>
                    <tr>
                        <td>C</td>
                        <td>‚àû</td>
                        <td>A ‚Üí C</td>
                        <td>5</td>
                    </tr>
                    <tr>
                        <td>D</td>
                        <td>‚àû</td>
                        <td>A ‚Üí C ‚Üí D</td>
                        <td>7</td>
                    </tr>
                    <tr>
                        <td>E</td>
                        <td>‚àû</td>
                        <td>A ‚Üí C ‚Üí D ‚Üí E</td>
                        <td>11</td>
                    </tr>
                    <tr>
                        <td>F</td>
                        <td>‚àû</td>
                        <td>A ‚Üí C ‚Üí D ‚Üí E ‚Üí F</td>
                        <td>18</td>
                    </tr>
                </table>
            </div>

            <div class="concepts" style="background: #ffe6f0; padding: 15px; border-left: 5px solid #e91e63; margin: 20px 0;">
                <h4>‚è∏Ô∏è PUNTO DE PAUSA: Ejercicio Manual</h4>
                <p><strong>Antes de continuar (5-10 minutos):</strong></p>
                <ol>
                    <li>Dibuja el grafo de la visualizaci√≥n en papel</li>
                    <li>Calcula manualmente las distancias desde A usando relajaci√≥n simple (2 rondas)</li>
                    <li><strong>Pregunta:</strong> ¬øPor qu√© el camino A‚ÜíB‚ÜíF (25) no es √≥ptimo para F? ¬øQu√© principio viola?</li>
                </ol>
                <p><em>No avances hasta completarlo.</em></p>
            </div>

            <div class="application">
                <h4>üåç Aplicaciones Reales</h4>
                
                <h5>Caso 1: GPS y Navegaci√≥n (Google Maps, Waze)</h5>
                <p><strong>Problema:</strong> Ruta m√°s r√°pida considerando tr√°fico din√°mico.</p>
                <ul>
                    <li>Pesos: Distancias + tiempo estimado (actualizado en tiempo real)</li>
                    <li>Soluci√≥n: Dijkstra con heap binario para actualizaciones r√°pidas</li>
                    <li>Escala: Millones de nodos (intersecciones), miles de consultas/segundo</li>
                </ul>
                
                <h5>Caso 2: Protocolos de Red (OSPF en Internet)</h5>
                <p><strong>Problema:</strong> Enrutamiento de paquetes IP con menor latencia.</p>
                <ul>
                    <li>Pesos: Costo de ancho de banda, latencia, congesti√≥n</li>
                    <li>Soluci√≥n: Dijkstra en cada router para tabla de enrutamiento</li>
                    <li>Impacto: 99% del tr√°fico web usa variantes de estos algoritmos</li>
                </ul>
                
                <h5>Caso 3: Log√≠stica y Cadena de Suministro (Amazon, UPS)</h5>
                <p><strong>Problema:</strong> Optimizaci√≥n de rutas de entrega multi-parada.</p>
                <ul>
                    <li>Pesos: Distancia + combustible + tiempo de carga</li>
                    <li>Soluci√≥n: Floyd-Warshall para precomputar todas las distancias en flotas grandes</li>
                    <li>Beneficio: Reducci√≥n de 10-20% en costos operativos</li>
                </ul>
            </div>

            <p><a href="#dijkstra">Continuar ‚Üí Dijkstra</a></p>
        </section>

        <!-- DIJKSTRA -->
        <section id="dijkstra" class="section">
            <h2>‚ö° 2.3.2. Algoritmo de Dijkstra: Implementaci√≥n y An√°lisis de Complejidad</h2>
            
            <h3>Concepto Fundamental</h3>
            <p><span class="emoji">üî¥</span> <strong>Dijkstra</strong> encuentra caminos m√°s cortos desde un origen √∫nico en grafos con <em>pesos no negativos</em>. Usa una <strong>cola de prioridad</strong> para expandir siempre el nodo con distancia m√≠nima conocida.</p>
            
            <div class="concepts">
                <h4>Caracter√≠sticas Clave</h4>
                <ul>
                    <li><strong>Estructura de Datos:</strong> Cola de prioridad (Heap) + conjunto de visitados</li>
                    <li><strong>Orden de Exploraci√≥n:</strong> Nodo con menor distancia tentadora</li>
                    <li><strong>Garant√≠a:</strong> √ìptimo para pesos ‚â• 0; no maneja negativos</li>
                    <li><strong>Complejidad Temporal:</strong> O((V + E) log V) con heap binario</li>
                    <li><strong>Complejidad Espacial:</strong> O(V) para distancias y heap</li>
                </ul>
            </div>

            <h3>Algoritmo Dijkstra Paso a Paso</h3>
            <ol>
                <li><strong>Inicializaci√≥n:</strong> Dist[origen] = 0; otros = ‚àû; cola_prioridad.insert(origen, 0)</li>
                <li><strong>Bucle Principal:</strong> Mientras cola no vac√≠a:
                    <ul>
                        <li>Extraer nodo u con m√≠nima distancia</li>
                        <li>Si u ya visitado, saltar</li>
                        <li>Marcar u visitado</li>
                        <li>Para cada vecino v de u:
                            <ul>
                                <li>Si Dist[u] + peso(u,v) < Dist[v]: actualizar Dist[v] y insertar/actualizar en cola</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><strong>Final:</strong> Dist[] contiene distancias m√≠nimas; reconstruir caminos con padres</li>
            </ol>

            <div class="visualization">
                <h4>üé® Visualizaci√≥n Dijkstra</h4>
                <p>Usando el grafo anterior desde A:</p>
                
                <div class="mermaid" data-alt="Ejecuci√≥n de Dijkstra con distancias actualizadas en nodos">
                graph TD
                    A((A<br/>0)) ---|10| B((B<br/>10))
                    A ---|5| C((C<br/>5))
                    B ---|3| D((D<br/>13))
                    C ---|2| D((D<br/>7))
                    C ---|8| E((E<br/>13))
                    D ---|4| E((E<br/>11))
                    B ---|15| F((F<br/>25))
                    E ---|7| F((F<br/>18))
                    
                    style A fill:#e74c3c,stroke:#c0392b,stroke-width:4px,color:#fff
                    style C fill:#f39c12,stroke:#e67e22,stroke-width:3px,color:#fff
                    style B fill:#3498db,stroke:#2980b9,stroke-width:3px,color:#fff
                    style D fill:#2ecc71,stroke:#27ae60,stroke-width:2px,color:#fff
                    style E fill:#1abc9c,stroke:#16a085,stroke-width:2px,color:#fff
                    style F fill:#9b59b6,stroke:#8e44ad,stroke-width:2px,color:#fff
                </div>
                
                <p><strong>Ejecuci√≥n Paso a Paso:</strong></p>
                <table>
                    <tr>
                        <th>Extra√≠do</th>
                        <th>Dist Actualizadas</th>
                        <th>Cola Prioridad (min-heap)</th>
                        <th>Visitados</th>
                    </tr>
                    <tr>
                        <td>-</td>
                        <td>Dist[A]=0</td>
                        <td>[(A,0)]</td>
                        <td>{}</td>
                    </tr>
                    <tr>
                        <td>A</td>
                        <td>Dist[B]=10, Dist[C]=5</td>
                        <td>[(C,5), (B,10)]</td>
                        <td>{A}</td>
                    </tr>
                    <tr>
                        <td>C</td>
                        <td>Dist[D]=7, Dist[E]=13</td>
                        <td>[(B,10), (D,7), (E,13)]</td>
                        <td>{A,C}</td>
                    </tr>
                    <tr>
                        <td>D</td>
                        <td>Dist[E]=11 (mejorado)</td>
                        <td>[(B,10), (E,11)]</td>
                        <td>{A,C,D}</td>
                    </tr>
                    <tr>
                        <td>B</td>
                        <td>Dist[F]=25 (nuevo)</td>
                        <td>[(E,11), (F,25)]</td>
                        <td>{A,C,D,B}</td>
                    </tr>
                    <tr>
                        <td>E</td>
                        <td>Dist[F]=18 (mejorado)</td>
                        <td>[(F,18)]</td>
                        <td>{A,C,D,B,E}</td>
                    </tr>
                    <tr>
                        <td>F</td>
                        <td>-</td>
                        <td>[]</td>
                        <td>{A,C,D,B,E,F}</td>
                    </tr>
                </table>
            </div>

            <div class="complexity">
                <h4>‚öôÔ∏è An√°lisis Riguroso de Complejidad</h4>
                
                <p>La complejidad temporal del algoritmo de Dijkstra no es un n√∫mero fijo sino que depende cr√≠ticamente de c√≥mo implementamos la cola de prioridad Q. Esta dependencia ilustra un principio fundamental en algor√≠tmica: la eficiencia de un algoritmo frecuentemente depende tanto de su l√≥gica de alto nivel como de los detalles de implementaci√≥n de bajo nivel.</p>
                
                <table>
                    <thead>
                        <tr>
                            <th>Estructura de Datos</th>
                            <th>EXTRACT-MIN</th>
                            <th>DECREASE-KEY</th>
                            <th>Complejidad Total</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Arreglo Simple</td>
                            <td>O(V)</td>
                            <td>O(1)</td>
                            <td>O(V¬≤)</td>
                        </tr>
                        <tr>
                            <td>Min-Heap Binario</td>
                            <td>O(log V)</td>
                            <td>O(log V)</td>
                            <td>O((V + E) log V)</td>
                        </tr>
                        <tr>
                            <td>Fibonacci Heap</td>
                            <td>O(log V)</td>
                            <td>O(1) amortizado</td>
                            <td>O(V log V + E)</td>
                        </tr>
                    </tbody>
                </table>
                
                <p><strong>An√°lisis Detallado con Min-Heap Binario:</strong> Esta es la implementaci√≥n m√°s com√∫n en la pr√°ctica porque ofrece un buen equilibrio entre eficiencia y simplicidad de implementaci√≥n. Un heap binario es un √°rbol completo donde cada padre tiene prioridad mayor o igual que sus hijos. Con esta estructura, EXTRACT-MIN requiere remover la ra√≠z y reheapificar, lo cual toma O(log V) tiempo. Ejecutamos esta operaci√≥n V veces, contribuyendo O(V log V) al tiempo total.</p>
                
                <p>Combinando ambas contribuciones, obtenemos O(V log V + E log V) que factorizamos como O((V + E) log V). Para grafos dispersos donde E es mucho menor que V¬≤, esto es significativamente mejor que la implementaci√≥n con arreglo simple.</p>
            </div>

            <div class="concepts" style="background: #f3e5f5; padding: 15px; border-left: 5px solid #9c27b0; margin: 20px 0;">
                <h4>‚è∏Ô∏è PUNTO DE PAUSA: An√°lisis de Complejidad</h4>
                <p><strong>Ejercicio (5 minutos):</strong></p>
                <p>En el grafo de ejemplo (V=6, E=8):</p>
                <ul>
                    <li><strong>Dijkstra con heap binario:</strong> ¬øCu√°ntas operaciones log V? (extraer V veces, insertar/actualizar hasta E veces)</li>
                    <li><strong>Versi√≥n ingenua (sin heap):</strong> O(V¬≤) ‚Äì ¬øPor qu√© peor en grafos dispersos?</li>
                    <li><strong>Pregunta:</strong> Si agregamos un nodo con 100 vecinos, ¬øc√≥mo afecta la complejidad?</li>
                </ul>
                <details>
                    <summary>Ver respuestas</summary>
                    <ul>
                        <li>O(V log V + E log V) ‚âà O(6 log 6 + 8 log 6) ‚âà 40 operaciones</li>
                        <li>Ing√©nua: O(V¬≤)=36, pero escalable peor en E >> V</li>
                        <li>Aumenta E, por lo que m√°s actualizaciones log V; heap maneja bien</li>
                    </ul>
                </details>
            </div>

            <div class="warning">
                <h4>‚ö†Ô∏è Limitaciones de Dijkstra</h4>
                <ul>
                    <li><strong>Pesos Negativos:</strong> No garantiza √≥ptimo; usa Bellman-Ford</li>
                    <li><strong>Grafos Densos:</strong> O(V¬≤) eficiente; dispersos prefieren heap</li>
                    <li><strong>Actualizaciones Din√°micas:</strong> Tr√°fico cambia ‚Üí re-ejecutar o A* (Semana 7)</li>
                </ul>
            </div>

            <p><a href="#floyd">Continuar ‚Üí Floyd-Warshall</a></p>
        </section>

        <!-- FLOYD-WARSHALL -->
        <section id="floyd" class="section">
            <h2>üîó 2.3.3. Algoritmo de Floyd-Warshall: Caminos M√°s Cortos entre Todos los Pares</h2>
            
            <h3>Concepto Fundamental</h3>
            <p><span class="emoji">üü£</span> <strong>Floyd-Warshall</strong> computa distancias m√≠nimas entre <em>todos los pares</em> de nodos usando <strong>programaci√≥n din√°mica</strong>. Considera cada nodo como posible intermediario.</p>
            
            <div class="concepts">
                <h4>Caracter√≠sticas Clave</h4>
                <ul>
                    <li><strong>Estructura de Datos:</strong> Matriz de distancias (V x V)</li>
                    <li><strong>Orden de Exploraci√≥n:</strong> Por nodos intermedios k=1 a V</li>
                    <li><strong>Garant√≠a:</strong> Maneja pesos negativos (sin ciclos negativos); detecta ciclos negativos</li>
                    <li><strong>Complejidad Temporal:</strong> O(V¬≥) ‚Äì fijo, independientemente de E</li>
                    <li><strong>Complejidad Espacial:</strong> O(V¬≤) para matriz</li>
                </ul>
            </div>

            <h3>Algoritmo Floyd-Warshall</h3>
            <pre><code>Para cada par (i,j): Dist[i][j] = peso(i,j) si arista, ‚àû si no, 0 si i==j

Para k = 1 a V:  // k como intermediario posible
    Para i = 1 a V:
        Para j = 1 a V:
            Si Dist[i][j] > Dist[i][k] + Dist[k][j]:
                Dist[i][j] = Dist[i][k] + Dist[k][j]
                Padre[i][j] = Padre[k][j]  // Para reconstruir camino</code></pre>

            <div class="visualization">
                <h4>üé® Visualizaci√≥n Floyd-Warshall</h4>
                <p>Matr√≠z inicial y evoluci√≥n para grafo peque√±o (nodos 1-3):</p>
                
                <div class="mermaid" data-alt="Evoluci√≥n de matriz en Floyd-Warshall por k">
                graph LR
                    subgraph "Matriz Inicial"
                    D1["1‚Üí1:0 | 1‚Üí2:4 | 1‚Üí3:‚àû"]
                    D2["2‚Üí1:‚àû | 2‚Üí2:0 | 2‚Üí3:2"]
                    D3["3‚Üí1:3 | 3‚Üí2:‚àû | 3‚Üí3:0"]
                    end
                    subgraph "Tras k=1"
                    E1["1‚Üí1:0 | 1‚Üí2:4 | 1‚Üí3:‚àû"]
                    E2["2‚Üí1:‚àû | 2‚Üí2:0 | 2‚Üí3:2"]
                    E3["3‚Üí1:3 | 3‚Üí2:‚àû | 3‚Üí3:0"]
                    end
                    subgraph "Tras k=2"
                    F1["1‚Üí1:0 | 1‚Üí2:4 | 1‚Üí3:6 (1-2-3)"]
                    F2["2‚Üí1:‚àû | 2‚Üí2:0 | 2‚Üí3:2"]
                    F3["3‚Üí1:3 | 3‚Üí2:‚àû | 3‚Üí3:0"]
                    end
                    subgraph "Tras k=3"
                    G1["1‚Üí1:0 | 1‚Üí2:4 | 1‚Üí3:6"]
                    G2["2‚Üí1:7 (2-3-1) | 2‚Üí2:0 | 2‚Üí3:2"]
                    G3["3‚Üí1:3 | 3‚Üí2:‚àû | 3‚Üí3:0"]
                    end
                </div>
                
                <p><strong>Resultado Final:</strong> Matriz completa de distancias m√≠nimas.</p>
            </div>

            <div class="application">
                <h4>üîç Aplicaciones Espec√≠ficas</h4>
                
                <h5>Caso 1: An√°lisis de Redes Complejas (Sociales, Biol√≥gicas)</h5>
                <p><strong>Problema:</strong> Distancias promedio entre todos los usuarios/prote√≠nas.</p>
                <ul>
                    <li>Floyd-Warshall precomputa para consultas r√°pidas O(1)</li>
                    <li>√ötil en grafos densos donde V es peque√±o (V<1000)</li>
                </ul>
                
                <h5>Caso 2: Optimizaci√≥n de Circuitos El√©ctricos</h5>
                <p><strong>Problema:</strong> Menor resistencia entre todos los nodos.</p>
                <ul>
                    <li>Pesos: Resistencias; detecta ciclos negativos (imposibles f√≠sicamente)</li>
                </ul>
                
                <h5>Caso 3: Planificaci√≥n Estrat√©gica (Matriz de Costos)</h5>
                <p><strong>Problema:</strong> Costos m√≠nimos entre todas las ciudades/almacenes.</p>
                <ul>
                    <li>Precomputar para decisiones r√°pidas en supply chain</li>
                </ul>
            </div>

            <div class="complexity">
                <h4>‚öôÔ∏è An√°lisis de Complejidad</h4>
                
                <p><strong>Complejidad Temporal:</strong> La estructura de tres bucles anidados, cada uno ejecut√°ndose V veces, resulta en complejidad temporal O(V¬≥). Esta complejidad c√∫bica es independiente del n√∫mero de aristas E: el algoritmo procesa todas las V¬≥ triplas posibles de nodos.</p>
                
                <p><strong>Complejidad Espacial:</strong> Requerimos espacio O(V¬≤) para almacenar la matriz de distancias D y la matriz de predecesores P. No necesitamos espacio adicional significativo m√°s all√° de variables auxiliares.</p>
                
                <p><strong>Ventajas de Floyd-Warshall:</strong> Su implementaci√≥n es extremadamente simple: apenas tres bucles for anidados sin estructuras de datos complejas. Esta simplicidad reduce la probabilidad de errores. Adem√°s, puede manejar aristas con pesos negativos siempre que no existan ciclos negativos. Finalmente, detecta ciclos negativos autom√°ticamente sin c√≥digo adicional.</p>
            </div>

            <div class="warning">
                <h4>‚ö†Ô∏è Cuidado con Floyd-Warshall</h4>
                <ul>
                    <li><strong>Escala:</strong> O(V¬≥) inviable para V>1000; usa Dijkstra x V para grandes grafos</li>
                    <li><strong>Ciclos Negativos:</strong> Detecta si Dist[i][i] < 0</li>
                    <li><strong>Espacio:</strong> O(V¬≤) ~ 1GB para V=10k; optimiza con sparse matrices</li>
                </ul>
            </div>

            <p><a href="#comparison">Continuar ‚Üí Comparaci√≥n</a></p>
        </section>

        <!-- COMPARACI√ìN -->
        <section id="comparison" class="section">
            <h2>‚öñÔ∏è 2.3.4. An√°lisis Comparativo: Dijkstra vs Floyd-Warshall</h2>
            
            <div class="comparison">
                <h3>Tabla Comparativa Exhaustiva</h3>
                <table>
                    <tr>
                        <th>Criterio</th>
                        <th>Dijkstra</th>
                        <th>Floyd-Warshall</th>
                    </tr>
                    <tr>
                        <td><strong>Problema Resuelto</strong></td>
                        <td>Un origen a todos</td>
                        <td>Todos los pares</td>
                    </tr>
                    <tr>
                        <td><strong>Pesos Negativos</strong></td>
                        <td>‚ùå No</td>
                        <td>‚úÖ S√≠ (sin ciclos neg.)</td>
                    </tr>
                    <tr>
                        <td><strong>Complejidad Temporal</strong></td>
                        <td>O((V+E) log V)</td>
                        <td>O(V¬≥)</td>
                    </tr>
                    <tr>
                        <td><strong>Complejidad Espacial</strong></td>
                        <td>O(V)</td>
                        <td>O(V¬≤)</td>
                    </tr>
                    <tr>
                        <td><strong>Mejor para Grafos</strong></td>
                        <td>Dispersos (E << V¬≤)</td>
                        <td>Densos (E ‚âà V¬≤)</td>
                    </tr>
                    <tr>
                        <td><strong>Implementaci√≥n</strong></td>
                        <td>Heap + lista ady.</td>
                        <td>Matriz DP</td>
                    </tr>
                    <tr>
                        <td><strong>Casos T√≠picos</strong></td>
                        <td>GPS, enrutamiento IP</td>
                        <td>An√°lisis redes, circuitos</td>
                    </tr>
                </table>
                
                <div class="concepts" style="margin-top: 20px; background: #fff3cd; padding: 15px; border-left: 5px solid #f39c12;">
                    <h4>üìê Mini-Ejercicio: Selecci√≥n √ìptima</h4>
                    <p><strong>Escenarios:</strong></p>
                    <table>
                        <tr>
                            <th>Escenario</th>
                            <th>V</th>
                            <th>E</th>
                            <th>Consulta</th>
                            <th>Algoritmo Recomendado</th>
                        </tr>
                        <tr>
                            <td>Red social (V=1M, E=10M)</td>
                            <td>1M</td>
                            <td>10M</td>
                            <td>Desde usuario X</td>
                            <td>Dijkstra</td>
                        </tr>
                        <tr>
                            <td>Circuito (V=50, E=1225)</td>
                            <td>50</td>
                            <td>1225</td>
                            <td>Todos los pares</td>
                            <td>Floyd-Warshall</td>
                        </tr>
                    </table>
                </div>
            </div>

            <div class="concepts">
                <h3>üß† Gu√≠a de Decisi√≥n</h3>
                <h4>Usa Dijkstra cuando:</h4>
                <ul>
                    <li>‚úÖ Un origen √∫nico, consultas repetidas desde mismo s</li>
                    <li>‚úÖ Grafos dispersos, pesos no negativos</li>
                    <li>‚úÖ Escala grande (V>1000)</li>
                </ul>
                <h4>Usa Floyd-Warshall cuando:</h4>
                <ul>
                    <li>‚úÖ Necesitas todos los pares, precomputaci√≥n OK</li>
                    <li>‚úÖ Grafos densos o peque√±os (V<500)</li>
                    <li>‚úÖ Posibles pesos negativos</li>
                </ul>
            </div>

            <p><a href="#solution-py">Continuar ‚Üí Implementaciones en C√≥digo</a></p>
        </section>

        <!-- CHECKPOINT PRE-C√ìDIGO -->
        <section class="section checkpoint">
            <h3 style="color: #e67e22; border-bottom: none;">‚è∏Ô∏è CHECKPOINT: Autoevaluaci√≥n Pre-C√≥digo</h3>
            <p><strong>Verifica comprensi√≥n:</strong></p>
            <ol>
                <li>¬øDiferencia clave entre BFS y Dijkstra?</li>
                <li>Verdadero/Falso: "Floyd-Warshall es O(V¬≤ log V)"</li>
                <li>¬øCu√°ndo falla Dijkstra?</li>
                <li>Pseudoc√≥digo: 3 pasos de Dijkstra</li>
            </ol>
            <details>
                <summary>Respuestas</summary>
                <ol>
                    <li>BFS: no pesos; Dijkstra: pesos no neg., usa heap</li>
                    <li>Falso: O(V¬≥)</li>
                    <li>Pesos negativos</li>
                    <li>1. Init dist/origen. 2. Extraer min, relajar vecinos. 3. Hasta cola vac√≠a</li>
                </ol>
            </details>
        </section>

        <!-- C√ìDIGO PYTHON -->
        <section id="solution-py" class="section">
            <h2>üêç Implementaci√≥n en Python</h2>
            <pre><code>import heapq
import math
from collections import defaultdict
from typing import Dict, List, Tuple

class WeightedGraph:
    def __init__(self, n: int):
        self.n = n
        self.adj = {i: [] for i in range(n)}
    
    def add_edge(self, u: int, v: int, w: float):
        self.adj[u].append((v, w))
        # Para no dirigido: self.adj[v].append((u, w))
    
    # Dijkstra
    def dijkstra(self, src: int) -> Tuple[List[float], List[int]]:
        dist = [math.inf] * self.n
        parent = [-1] * self.n
        dist[src] = 0
        pq = [(0, src)]  # (dist, node)
        visited = [False] * self.n
        
        while pq:
            cost, u = heapq.heappop(pq)
            if visited[u]: continue
            visited[u] = True
            
            for v, w in self.adj[u]:
                if dist[u] + w < dist[v]:
                    dist[v] = dist[u] + w
                    parent[v] = u
                    heapq.heappush(pq, (dist[v], v))
        
        return dist, parent
    
    # Floyd-Warshall
    def floyd_warshall(self) -> List[List[float]]:
        dist = [[math.inf] * self.n for _ in range(self.n)]
        for i in range(self.n):
            dist[i][i] = 0
        
        for u in range(self.n):
            for v, w in self.adj[u]:
                dist[u][v] = w
        
        for k in range(self.n):
            for i in range(self.n):
                for j in range(self.n):
                    if dist[i][k] + dist[k][j] < dist[i][j]:
                        dist[i][j] = dist[i][k] + dist[k][j]
        
        # Detectar ciclos negativos
        for i in range(self.n):
            if dist[i][i] < 0:
                raise ValueError("Ciclo negativo detectado")
        
        return dist

# Ejemplo de uso
g = WeightedGraph(6)
g.add_edge(0,1,10); g.add_edge(0,2,5)
g.add_edge(1,3,3); g.add_edge(2,3,2); g.add_edge(2,4,8)
g.add_edge(3,4,4); g.add_edge(1,5,15); g.add_edge(4,5,7)

dist, parent = g.dijkstra(0)
print(f"Dist a F: {dist[5]}")  # 18

fw = g.floyd_warshall()
print(f"FW dist 0-5: {fw[0][5]}")  # 18
</code></pre>
        </section>

        <!-- APLICACIONES -->
        <section id="applications" class="section">
            <h2>üåê Aplicaciones Pr√°cticas</h2>
            
            <div class="application">
                <h3>Caso 1: Optimizador de Rutas GPS con Tr√°fico</h3>
                <pre><code># Python: Extensi√≥n de Dijkstra con pesos din√°micos
def dijkstra_con_trafico(grafo: WeightedGraph, src: int, trafico_actual: Dict[Tuple[int, int], float]):
    # trafico_actual: dict de aristas a multiplicador (1.0 normal, 2.0 congestionado)
    dist, parent = grafo.dijkstra(src)
    # Post-procesar: ajustar pesos con tr√°fico y re-relajar si necesario
    # (Implementaci√≥n simplificada; en prod usa A* con heur√≠stica)
    return dist, parent
</code></pre>
            </div>

            <div class="application">
                <h3>Caso 2: An√°lisis de Redes IP (Protocolo OSPF)</h3>
                <pre><code># Python: Simulaci√≥n de router
class Router:
    def compute_routing_table(self, network: WeightedGraph, this_router: int):
        dist, _ = network.dijkstra(this_router)
        return dist  # Tabla: dist a cada destino

router = Router()
# Uso similar
</code></pre>
            </div>

            <div class="application">
                <h3>Caso 3: An√°lisis de Accesibilidad Urbana</h3>
                <p><strong>Contexto:</strong> Calcular tiempos de respuesta de emergencias desde hospitales.</p>
                <pre><code># Usando Floyd-Warshall para precomputar
def analizar_accesibilidad(grafo_hospitales: WeightedGraph, hospitales: List[int], nodos_ciudad: List[int]):
    matriz_tiempos = grafo_hospitales.floyd_warshall()
    accesibilidad = {}
    for hospital in hospitales:
        for ciudad in nodos_ciudad:
            tiempo = matriz_tiempos[hospital][ciudad]
            if tiempo <= 15:  # Minutos aceptable
                accesibilidad[ciudad] = 'Alta'
            else:
                accesibilidad[ciudad] = 'Baja'
    return accesibilidad
</code></pre>
            </div>

            <div class="application" style="background: #f0f8ff; border-left: 5px solid #4a90e2;">
                <h3>Caso 4: Optimizaci√≥n en Finanzas (Arbitraje en Cripto)</h3>
                <p><strong>Contexto:</strong> Detectar oportunidades de arbitraje en exchanges de criptomonedas.</p>
                <pre><code># Grafo: Nodos=exchanges, Pesos=1/cotizaci√≥n (menor peso = mejor tasa)
def detectar_arbitraje(grafo_cripto: WeightedGraph):
    try:
        fw = grafo_cripto.floyd_warshall()
        for i in range(grafo_cripto.n):
            if fw[i][i] < 0:  # Ciclo negativo = arbitraje
                print(f"¬°Oportunidad! Ciclo en {i}: ganancia {abs(fw[i][i])}%")
    except ValueError:
        print("Ciclo negativo: arbitraje posible")
</code></pre>
                <p><strong>Advertencia:</strong> En la pr√°ctica, incluye fees y latencia; usa Dijkstra para rutas espec√≠ficas.</p>
            </div>

            <p><a href="#test-cases">Continuar ‚Üí Casos de Prueba</a></p>
        </section>

        <!-- CASOS DE PRUEBA -->
        <section id="test-cases" class="section">
            <h2>üß™ Casos de Prueba</h2>
            
            <h3>Suite de Pruebas para Dijkstra</h3>
            <table>
                <tr>
                    <th>#</th>
                    <th>Descripci√≥n</th>
                    <th>Input</th>
                    <th>Salida Esperada</th>
                </tr>
                <tr>
                    <td>1</td>
                    <td>Grafo ponderado simple</td>
                    <td>Aristas: (0,1,10),(0,2,5),(2,3,2),(1,3,3); src=0</td>
                    <td>Dist[3]=7 (v√≠a 0-2-3)</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>Grafo con pesos cero</td>
                    <td>Aristas: (0,1,0),(1,2,5); src=0</td>
                    <td>Dist[2]=5</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>Grafo desconectado</td>
                    <td>Aristas: (0,1,10); src=0</td>
                    <td>Dist[2]=‚àû</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>Nodo √∫nico</td>
                    <td>Sin aristas; src=0</td>
                    <td>Dist[0]=0</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td>Camino m√°s corto con m√∫ltiples opciones</td>
                    <td>Aristas: (0,1,4),(0,2,2),(1,3,1),(2,3,3); src=0</td>
                    <td>Dist[3]=3 (v√≠a 0-1-3)</td>
                </tr>
            </table>

            <h3>Suite de Pruebas para Floyd-Warshall</h3>
            <table>
                <tr>
                    <th>#</th>
                    <th>Descripci√≥n</th>
                    <th>Input</th>
                    <th>Salida Esperada</th>
                </tr>
                <tr>
                    <td>6</td>
                    <td>Grafo denso peque√±o</td>
                    <td>Aristas: (0,1,4),(1,2,2),(2,0,3)</td>
                    <td>Dist[0][2]=5 (0-1-2)</td>
                </tr>
                <tr>
                    <td>7</td>
                    <td>Con pesos negativos (sin ciclo)</td>
                    <td>Aristas: (0,1,2),(1,2,-1)</td>
                    <td>Dist[0][2]=1 (0-1-2)</td>
                </tr>
                <tr>
                    <td>8</td>
                    <td>Ciclo negativo detectado</td>
                    <td>Aristas: (0,1,-2),(1,0,-1)</td>
                    <td>Excepci√≥n: Ciclo negativo</td>
                </tr>
                <tr>
                    <td>9</td>
                    <td>Grafo completo</td>
                    <td>3 nodos, todas aristas</td>
                    <td>Matriz completa con m√≠nimas</td>
                </tr>
                <tr>
                    <td>10</td>
                    <td>Desconectado</td>
                    <td>Aristas: (0,1,10); nodos 0-2</td>
                    <td>Dist[0][2]=‚àû</td>
                </tr>
            </table>

            <h3>Tests Unitarios en Python (pytest)</h3>
            <pre><code>import pytest
import math
from weighted_graph import WeightedGraph  # Asumir archivo con clase

def test_dijkstra_simple():
    g = WeightedGraph(4)
    g.add_edge(0, 1, 10)
    g.add_edge(0, 2, 5)
    g.add_edge(2, 3, 2)
    g.add_edge(1, 3, 3)
    
    dist, _ = g.dijkstra(0)
    assert dist[3] == 7
    assert math.isinf(dist[3]) == False

def test_dijkstra_zero_weight():
    g = WeightedGraph(3)
    g.add_edge(0, 1, 0)
    g.add_edge(1, 2, 5)
    
    dist, _ = g.dijkstra(0)
    assert dist[2] == 5

def test_dijkstra_disconnected():
    g = WeightedGraph(3)
    g.add_edge(0, 1, 10)
    
    dist, _ = g.dijkstra(0)
    assert math.isinf(dist[2])

def test_dijkstra_single_node():
    g = WeightedGraph(1)
    
    dist, _ = g.dijkstra(0)
    assert dist[0] == 0

def test_floyd_warshall_simple():
    g = WeightedGraph(3)
    g.add_edge(0, 1, 4)
    g.add_edge(1, 2, 2)
    g.add_edge(2, 0, 3)
    
    fw = g.floyd_warshall()
    assert fw[0][2] == 5  # 0-1-2

def test_floyd_warshall_negative_no_cycle():
    g = WeightedGraph(3)
    g.add_edge(0, 1, 2)
    g.add_edge(1, 2, -1)
    
    fw = g.floyd_warshall()
    assert fw[0][2] == 1

def test_floyd_warshall_negative_cycle():
    g = WeightedGraph(2)
    g.add_edge(0, 1, -2)
    g.add_edge(1, 0, -1)
    
    with pytest.raises(ValueError):
        g.floyd_warshall()

def test_floyd_warshall_disconnected():
    g = WeightedGraph(3)
    g.add_edge(0, 1, 10)
    
    fw = g.floyd_warshall()
    assert math.isinf(fw[0][2])

# Edge cases
def test_dijkstra_non_existent_src():
    g = WeightedGraph(1)
    with pytest.raises(IndexError):
        g.dijkstra(1)

def test_floyd_warshall_empty():
    g = WeightedGraph(0)
    with pytest.raises(ValueError):
        g.floyd_warshall()

if __name__ == "__main__":
    pytest.main([__file__, "-v"])
</code></pre>

            <div class="concepts" style="background: #e8f8f5; padding: 15px; border-left: 5px solid #1abc9c; margin: 20px 0;">
                <h4>‚ñ∂Ô∏è C√≥mo Ejecutar los Tests</h4>
                <pre><code># En terminal
pip install pytest  # Si no instalado
pytest test_weighted_graph.py -v

# Espec√≠ficos
pytest test_weighted_graph.py::test_dijkstra_simple -v

# Cobertura
pytest --cov=weighted_graph test_weighted_graph.py

# Detener en error
pytest -x

# Ver prints
pytest -s
</code></pre>
                <p><strong>Salida esperada:</strong> 10 passed in 0.10s</p>
            </div>

            <p><a href="#ia-activities">Continuar ‚Üí Actividades con IA</a></p>
        </section>

        <!-- ACTIVIDADES IA -->
        <section id="ia-activities" class="section">
            <h2>ü§ñ Actividades con Inteligencia Artificial</h2>
            
            <div class="ia-activity">
                <h3><span class="prompt-number">PROMPT #1</span> An√°lisis Comparativo Personalizado</h3>
                <h4>Objetivo: Profundizar entendimiento de Dijkstra vs Floyd-Warshall</h4>
                
                <div class="ia-prompt">Contexto: Soy estudiante de estructuras de datos y acabo de implementar Dijkstra y Floyd-Warshall en Python.

Tarea: Genera 5 escenarios de problemas del mundo real (ej. GPS, redes IP, log√≠stica) y para cada uno:
1. Describe brevemente el problema
2. Explica si usar√≠as Dijkstra o Floyd-Warshall y POR QU√â
3. Justifica tu elecci√≥n con propiedades espec√≠ficas del algoritmo (complejidad, garant√≠as, etc.)
4. Menciona una desventaja de usar el otro algoritmo

Formato: Tabla comparativa concisa.</div>
                
                <p><strong>Reflexi√≥n Post-IA:</strong></p>
                <ul>
                    <li>¬øLos escenarios del IA coinciden con tu intuici√≥n?</li>
                    <li>¬øIdentificaste alg√∫n caso donde ambos algoritmos son igualmente v√°lidos?</li>
                    <li>¬øQu√© criterio adicional no mencion√≥ la IA que consideras importante?</li>
                </ul>
            </div>

            <div class="ia-activity">
                <h3><span class="prompt-number">PROMPT #2</span> Optimizaci√≥n de C√≥digo</h3>
                <h4>Objetivo: Mejorar implementaciones</h4>
                
                <div class="ia-prompt">Aqu√≠ est√° mi implementaci√≥n de Dijkstra en Python:

[PEGA TU C√ìDIGO AQU√ç]

Tarea: Analiza mi c√≥digo y sugiere mejoras en:
1. **Eficiencia:** ¬øHay operaciones redundantes? ¬øSe puede optimizar complejidad espacial?
2. **Claridad:** ¬øEl c√≥digo es legible? ¬øLos nombres de variables son descriptivos?
3. **Robustez:** ¬øManeja casos l√≠mite (grafo vac√≠o, nodo inexistente, pesos negativos)?
4. **Extensibilidad:** ¬øQu√© funcionalidad adicional ser√≠a √∫til? (ej. Dijkstra bidireccional)

Formato: Enumera mejoras con c√≥digo de ejemplo para cada una.</div>
                
                <p><strong>Actividad de Validaci√≥n:</strong></p>
                <ol>
                    <li>Implementa <strong>al menos 2</strong> de las mejoras sugeridas</li>
                    <li>Ejecuta tests antes y despu√©s para verificar que funcionan</li>
                    <li>Documenta el cambio en comentarios: <code># Optimizaci√≥n sugerida por IA: [descripci√≥n]</code></li>
                </ol>
            </div>

            <div class="ia-activity">
                <h3><span class="prompt-number">PROMPT #3</span> Depuraci√≥n con IA</h3>
                <h4>Objetivo: Resolver bugs usando IA como asistente</h4>
                
                <div class="ia-prompt">Mi implementaci√≥n de Floyd-Warshall est√° fallando el siguiente test:

**Input:** Grafo: 0‚Üí1:2, 1‚Üí2:-1, 2‚Üí0:-4 (deber√≠a detectar ciclo negativo)
**Resultado esperado:** ValueError (ciclo negativo)
**Resultado obtenido:** No lanza excepci√≥n, calcula dist[0][0]=-3

Mi c√≥digo:
[PEGA TU C√ìDIGO DE floyd_warshall AQU√ç]

Tarea: 
1. Identifica el bug explicando la l√≥gica incorrecta
2. Sugiere la correcci√≥n espec√≠fica
3. Explica por qu√© esa correcci√≥n funciona
4. Proporciona una traza paso a paso del algoritmo corregido con el input de ejemplo</div>
                
                <p><strong>Proceso de Aprendizaje:</strong></p>
                <ul>
                    <li>Antes de ver la respuesta de IA, intenta depurar manualmente por 10 minutos</li>
                    <li>Compara tu diagn√≥stico con el de la IA</li>
                    <li>Aplica la correcci√≥n y valida con tests adicionales</li>
                </ul>
            </div>

            <div class="ia-activity">
                <h3><span class="prompt-number">PROMPT #4</span> Generaci√≥n de Visualizaciones</h3>
                <h4>Objetivo: Crear diagramas Mermaid para documentar</h4>
                
                <div class="ia-prompt">Necesito visualizar la ejecuci√≥n de Floyd-Warshall en el siguiente grafo ponderado para mi reporte:

**Grafo (lista de adyacencia con pesos):**
{
  0: [(1,4), (2,11)],
  1: [(2,2)],
  2: [(0,6), (3,7)],
  3: [(1,2)]
}

Tarea: Genera:
1. Diagrama Mermaid del grafo con pesos en aristas
2. Tabla HTML paso a paso de FW mostrando matriz tras cada k: [k | Matriz Dist]
3. Sugerencias de c√≥mo colorear celdas por actualizaci√≥n en Mermaid o HTML

Formato: C√≥digo Mermaid listo para copiar + tabla HTML.</div>
                
                <p><strong>Post-Procesamiento:</strong></p>
                <ol>
                    <li>Copia el c√≥digo Mermaid y verifica que renderiza correctamente</li>
                    <li>Si hay errores de sintaxis, pide correcciones espec√≠ficas a la IA</li>
                    <li>Personaliza colores/estilos para que coincidan con tu reporte</li>
                    <li><strong>Documenta:</strong> "Visualizaci√≥n generada con IA (PROMPT #4), estilos personalizados manualmente"</li>
                </ol>
            </div>

            <div class="ia-activity">
                <h3><span class="prompt-number">PROMPT #5</span> Caso de Estudio Avanzado</h3>
                <h4>Objetivo: Aplicar Dijkstra/FW a problema complejo</h4>
                
                <div class="ia-prompt">**Problema:** Optimizaci√≥n de red de transporte p√∫blico en una ciudad

Contexto: Tengo un grafo de 50 estaciones de metro con tiempos de viaje ponderados. Necesito:
1. Calcular tiempos desde cada estaci√≥n central a todas (Dijkstra x V)
2. Precomputar matriz completa para consultas r√°pidas (Floyd-Warshall)
3. Identificar "estaciones bottleneck" (alta centralidad de distancia)
4. Simular impacto de cerrar una estaci√≥n (re-ejecutar FW)
5. Recomendar nuevas conexiones para reducir tiempo promedio

Entregables:
- Pseudoc√≥digo de las 5 funcionalidades en Python
- Estructura de datos recomendada (NetworkX?)
- An√°lisis de complejidad y trade-offs
- Ejemplo con 5 estaciones reales de CDMX</div>
                
                <p><strong>Proyecto Mini:</strong></p>
                <ul>
                    <li>Implementa el sistema propuesto por la IA en Python</li>
                    <li>Usa datos reales de metro (o inventa 10 estaciones coherentes)</li>
                    <li>Genera un reporte PDF con: matriz FW, visualizaci√≥n de bottlenecks, recomendaciones</li>
                    <li><strong>Reflexi√≥n cr√≠tica:</strong> ¬øLa soluci√≥n de IA es √≥ptima? ¬øQu√© mejorar√≠as?</li>
                </ul>
            </div>

            <div class="checklist">
                <h3>‚úÖ R√∫brica de Uso √âtico de IA</h3>
                <p><strong>Para aprobar las actividades con IA, debes demostrar:</strong></p>
                <ul>
                    <li><input type="checkbox" aria-label="Atribuci√≥n"> <strong>Atribuci√≥n:</strong> Cada uso de IA est√° documentado con n√∫mero de prompt (ej. PROMPT #2)</li>
                    <li><input type="checkbox" aria-label="Comprensi√≥n"> <strong>Comprensi√≥n:</strong> Puedes explicar verbalmente cualquier c√≥digo/idea generada por IA</li>
                    <li><input type="checkbox" aria-label="Modificaci√≥n"> <strong>Modificaci√≥n:</strong> Has personalizado o mejorado las respuestas de IA (no copiar-pegar ciego)</li>
                    <li><input type="checkbox" aria-label="Validaci√≥n"> <strong>Validaci√≥n:</strong> Has verificado la correcci√≥n de las sugerencias de IA con tests</li>
                    <li><input type="checkbox" aria-label="Reflexi√≥n"> <strong>Reflexi√≥n:</strong> Incluyes an√°lisis cr√≠tico: ¬øqu√© hizo bien la IA? ¬øqu√© falt√≥?</li>
                </ul>
                
                <p><strong>‚ùå Uso No √âtico de IA (resulta en 0 puntos):</strong></p>
                <ul>
                    <li>Copiar c√≥digo de IA sin entender c√≥mo funciona</li>
                    <li>No poder explicar o reproducir tu soluci√≥n en vivo</li>
                    <li>No documentar el uso de IA en el reporte/c√≥digo</li>
                    <li>Usar IA para resolver todo sin esfuerzo propio significativo</li>
                </ul>
            </div>

            <p><a href="#project">Continuar ‚Üí Proyecto Integrador</a></p>
        </section>

        <!-- PROYECTO INTEGRADOR -->
        <section id="project" class="section project">
            <h2>üöÄ Proyecto Integrador: Avance 4 - Optimizaci√≥n de Rutas Urbanas</h2>
            
            <h3>Semana 6: Integraci√≥n de Algoritmos Ponderados</h3>
            <p><strong>Fecha l√≠mite:</strong> Fin de Semana 6 | <strong>Valor:</strong> 25% del proyecto total</p>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                <div>
                    <h4>üìã Requisitos Funcionales</h4>
                    <ol>
                        <li><strong>Implementar Dijkstra Completo:</strong>
                            <ul>
                                <li>Distancias ponderadas desde intersecci√≥n origen</li>
                                <li>Camino m√°s corto reconstruido con padres</li>
                                <li>Manejo de pesos din√°micos (ej. tr√°fico)</li>
                            </ul>
                        </li>
                        <li><strong>Implementar Floyd-Warshall:</strong>
                            <ul>
                                <li>Matriz de todos los pares</li>
                                <li>Detecci√≥n de ciclos negativos (si aplica)</li>
                                <li>Reconstrucci√≥n de caminos v√≠a matriz padre</li>
                            </ul>
                        </li>
                        <li><strong>An√°lisis Pr√°ctico:</strong>
                            <ul>
                                <li>Tiempo promedio de viaje en tu ciudad</li>
                                <li>Estaciones "centrales" (menor distancia media)</li>
                                <li>Impacto de cerrar una intersecci√≥n clave</li>
                            </ul>
                        </li>
                        <li><strong>Aplicaci√≥n de Caso de Uso:</strong>
                            <ul>
                                <li>Elige 1: Optimizador GPS con tr√°fico, An√°lisis de accesibilidad, o Planificaci√≥n log√≠stica</li>
                                <li>Implementa usando Dijkstra/FW en Python</li>
                            </ul>
                        </li>
                    </ol>
                </div>
                <div>
                    <h4>üìÑ Entregables</h4>
                    <ul>
                        <li><strong>C√≥digo:</strong>
                            <ul>
                                <li>Integraci√≥n de algoritmos ponderados al proyecto</li>
                                <li>Clases: <code>WeightedGraph</code>, <code>RouteOptimizer</code></li>
                                <li>Tests unitarios (m√≠nimo 10 tests)</li>
                            </ul>
                        </li>
                        <li><strong>Reporte PDF (6-8 p√°ginas):</strong>
                            <ul>
                                <li>An√°lisis de distancias ponderadas en el mapa</li>
                                <li>Tabla: 5 rutas √≥ptimas con tiempos y caminos</li>
                                <li>Visualizaci√≥n: Matriz FW resumida + grafo con pesos</li>
                                <li>Caso de uso: descripci√≥n + resultados num√©ricos</li>
                                <li>An√°lisis comparativo Dijkstra vs FW en tu contexto</li>
                                <li>Reflexi√≥n: ¬øQu√© algoritmo escal√≥ mejor en tu grafo?</li>
                            </ul>
                        </li>
                        <li><strong>(Opcional) Demo Interactivo:</strong>
                            <ul>
                                <li>App Streamlit/Flask para consultar rutas</li>
                                <li>Visualizaci√≥n de caminos en mapa (Folium/NetworkX)</li>
                                <li>+10% bonus en este avance</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="warning">
                <h4>‚ö†Ô∏è Errores Comunes a Evitar en el Avance 4</h4>
                <ul>
                    <li>No integrar con c√≥digo de semanas previas (BFS/DFS)</li>
                    <li>Olvidar pesos negativos en FW (no detectarlos)</li>
                    <li>Usar FW para grafos grandes (V>200) sin justificaci√≥n</li>
                    <li>No reconstruir caminos (solo distancias)</li>
                    <li>An√°lisis sin datos reales (usa pesos de distancias reales)</li>
                    <li>No probar con tr√°fico din√°mico en Dijkstra</li>
                    <li>Reporte sin visualizaciones cuantitativas (tablas/matrices)</li>
                </ul>
            </div>

            <div class="concepts">
                <h4>üí° Sugerencias de Caso de Uso Sobresaliente</h4>
                
                <p><strong>Opci√≥n 1: Simulador de Tr√°fico Din√°mico</strong></p>
                <ul>
                    <li>Modifica pesos en runtime (tr√°fico +20% en horas pico)</li>
                    <li>Compara Dijkstra antes/durante pico</li>
                    <li>Visualiza cambios en mapa con colores (rojo=congesti√≥n)</li>
                </ul>
                
                <p><strong>Opci√≥n 2: An√°lisis de Resiliencia Urbana</strong></p>
                <ul>
                    <li>Usa FW para baseline, luego remueve aristas y re-ejecuta</li>
                    <li>Identifica "puentes cr√≠ticos" (aumento >50% en dist media)</li>
                    <li>Propone alternativas (nuevas aristas)</li>
                </ul>
                
                <p><strong>Opci√≥n 3: Optimizador Log√≠stico Multi-Modal</strong></p>
                <ul>
                    <li>Integra modos: auto (Dijkstra), todos pares (FW para planificaci√≥n)</li>
                    <li>Pesos h√≠bridos: tiempo + costo CO2</li>
                    <li>Calcula rutas "verdes" vs "r√°pidas"</li>
                </ul>
            </div>

            <div class="checklist">
                <h3>‚úÖ Checklist de Pre-Entrega (Avance 4)</h3>
                <ul>
                    <li><input type="checkbox" aria-label="Dijkstra implementado"> Dijkstra con heap y reconstrucci√≥n de caminos</li>
                    <li><input type="checkbox" aria-label="FW implementado"> Floyd-Warshall con detecci√≥n de ciclos negativos</li>
                    <li><input type="checkbox" aria-label="Integraci√≥n"> C√≥digo integrado con Semanas 3-5 (grafo ponderado cohesivo)</li>
                    <li><input type="checkbox" aria-label="Tests"> M√≠nimo 10 tests unitarios pasando (5 Dijkstra + 5 FW)</li>
                    <li><input type="checkbox" aria-label="An√°lisis ponderado"> An√°lisis de tiempos/dist ponderadas completado</li>
                    <li><input type="checkbox" aria-label="Caso de uso"> Caso de uso implementado y documentado</li>
                    <li><input type="checkbox" aria-label="Visualizaciones"> Al menos 2 visualizaciones (matriz + grafo ponderado)</li>
                    <li><input type="checkbox" aria-label="Tabla rutas"> Tabla con 5 rutas √≥ptimas y comparaciones</li>
                    <li><input type="checkbox" aria-label="An√°lisis comp"> An√°lisis cr√≠tico Dijkstra vs FW en tu grafo</li>
                    <li><input type="checkbox" aria-label="Atribuci√≥n IA"> (Si aplica) Uso de IA documentado con n√∫meros de prompt</li>
                </ul>
            </div>

            <h4>üìä Criterios de Evaluaci√≥n del Avance 4</h4>
            <table>
                <tr>
                    <th>Componente</th>
                    <th>Puntos</th>
                    <th>Criterio de Excelencia</th>
                </tr>
                <tr>
                    <td><strong>Implementaci√≥n Dijkstra</strong></td>
                    <td>20</td>
                    <td>Eficiente con heap, maneja din√°micos, reconstruye caminos</td>
                </tr>
                <tr>
                    <td><strong>Implementaci√≥n FW</strong></td>
                    <td>20</td>
                    <td>DP correcto, detecta negativos, matriz padre para paths</td>
                </tr>
                <tr>
                    <td><strong>Aplicaci√≥n al Mapa Real</strong></td>
                    <td>20</td>
                    <td>An√°lisis ponderado profundo, resultados realistas</td>
                </tr>
                <tr>
                    <td><strong>Caso de Uso Pr√°ctico</strong></td>
                    <td>15</td>
                    <td>Implementaci√≥n innovadora, impacto medible (reducci√≥n %)</td>
                </tr>
                <tr>
                    <td><strong>Reporte T√©cnico</strong></td>
                    <td>15</td>
                    <td>Visuales claras, tablas num√©ricas, insights accionables</td>
                </tr>
                <tr>
                    <td><strong>Tests y Calidad</strong></td>
                    <td>10</td>
                    <td>Tests exhaustivos, c√≥digo limpio PEP8, documentado</td>
                </tr>
                <tr>
                    <td><strong>Bonus: Demo Interactivo</strong></td>
                    <td>+10</td>
                    <td>App funcional, UI intuitiva, datos en tiempo real simulado</td>
                </tr>
            </table>

            <div class="concepts" style="margin-top: 20px;">
                <p><strong>üéì Conexi√≥n Pedag√≥gica:</strong> Este avance extiende la exploraci√≥n (Semana 5) a optimizaci√≥n ponderada, preparando para:</p>
                <ul>
                    <li><strong>Semana 7:</strong> Bellman-Ford (negativos), A* (heur√≠sticas)</li>
                    <li><strong>Semana 8:</strong> √Årboles MST (Prim/Kruskal) para infra</li>
                    <li><strong>Semana 9+:</strong> Flujos, matching, aproximaciones NP</li>
                </ul>
                <p>Enf√≥cate en trade-offs: ¬øcu√°ndo precomputar (FW) vs computar on-demand (Dijkstra)? Es clave en sistemas reales.</p>
            </div>

            <p style="text-align: center; margin-top: 30px; font-size: 1.1em;">
                <a href="#intro" style="margin: 0 15px;">‚úì Marcar Semana 6 como Completada</a> | 
                <a href="#intro" style="margin: 0 15px;">üîÑ Volver al Inicio</a>
            </p>
        </section>

        <footer>
            <p><strong>Estructuras de Datos Avanzadas - Semana 6</strong></p>
            <p><em>Algoritmos de Optimizaci√≥n en Grafos Ponderados ¬© 2025</em></p>
            <p style="font-size: 0.9em; margin-top: 10px;">
                "Dijkstra y Floyd-Warshall no solo calculan distancias; optimizan el flujo del mundo moderno, desde paquetes de datos hasta entregas globales."
            </p>
            <p>Dr Eligardo Cruz S√°nchez |  Universidad Aut√≥noma de Nayarit</p>
        </footer>

    </div>
</body>
</html>