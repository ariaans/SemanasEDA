<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üå≤ Semana 8 ‚Äì Estructuras de Datos Arb√≥reas Especializadas</title>
    <style>
        /* Reset y configuraci√≥n base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            padding: 20px;
            background-color: #f9f9f9;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        /* Tipograf√≠a */
        h1 {
            text-align: center;
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        h2 {
            color: #2c3e50;
            border-bottom: 2px solid #8e44ad;
            padding-bottom: 10px;
            margin: 40px 0 20px 0;
        }

        h3 {
            color: #2c3e50;
            border-bottom: 1px solid #bdc3c7;
            padding-bottom: 8px;
            margin: 25px 0 15px 0;
        }

        h4 {
            color: #8e44ad;
            margin: 20px 0 10px 0;
            font-weight: 600;
        }

        p {
            margin-bottom: 15px;
        }

        /* Navegaci√≥n */
        nav ul {
            list-style: none;
            display: flex;
            justify-content: space-around;
            background: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        nav li {
            margin: 5px 10px;
        }

        nav a {
            text-decoration: none;
            color: #2c3e50;
            font-weight: 500;
            transition: color 0.3s;
        }

        nav a:hover {
            color: #8e44ad;
        }

        /* Cajas did√°cticas */
        .engage {
            background: #e3f2fd;
            padding: 20px;
            border-left: 5px solid #2196f3;
            border-radius: 5px;
            margin: 20px 0;
        }

        .objectives {
            background: #f3e5f5;
            padding: 20px;
            border-left: 5px solid #9b59b6;
            border-radius: 5px;
            margin: 20px 0;
        }

        .concepts {
            background: #fff3cd;
            padding: 20px;
            border-left: 5px solid #ffc107;
            border-radius: 5px;
            margin: 20px 0;
        }

        .visualization {
            background: #f0f4c3;
            padding: 20px;
            border-left: 5px solid #cddc39;
            border-radius: 5px;
            margin: 20px 0;
        }

        .comparison {
            background: #fef5e7;
            padding: 20px;
            border-left: 5px solid #f39c12;
            border-radius: 5px;
            margin: 20px 0;
        }

        .application {
            background: #ebf5fb;
            padding: 20px;
            border-left: 5px solid #5dade2;
            border-radius: 5px;
            margin: 20px 0;
        }

        .warning {
            background: #fbe9e7;
            padding: 20px;
            border-left: 5px solid #ff5722;
            border-radius: 5px;
            margin: 20px 0;
        }

        .gamification {
            background: #f3e5f5;
            padding: 20px;
            border-left: 5px solid #9c27b0;
            border-radius: 5px;
            margin: 20px 0;
            border: 2px dashed #9c27b0;
        }

        .checkpoint {
            background: #fffbea;
            padding: 25px;
            border: 3px dashed #f39c12;
            border-radius: 10px;
            margin: 30px 0;
        }

        .project {
            background: #d1ecf1;
            padding: 20px;
            border-left: 5px solid #17a2b8;
            border-radius: 5px;
            margin: 20px 0;
        }

        .ia-activity {
            background: #e7d4f7;
            padding: 20px;
            border-left: 5px solid #9b59b6;
            border-radius: 5px;
            margin: 20px 0;
        }

        .checklist {
            background: #d4edda;
            padding: 20px;
            border-left: 5px solid #28a745;
            border-radius: 5px;
            margin: 20px 0;
        }

        .math-def {
            background: #fafafa;
            border: 1px solid #ccc;
            padding: 15px;
            border-radius: 5px;
            font-family: "Times New Roman", serif;
            font-size: 1.05em;
            text-align: center;
            margin: 20px 0;
        }

        .algorithm-box {
            background: #e8eaf6;
            padding: 20px;
            border-left: 5px solid #3f51b5;
            border-radius: 5px;
            margin: 20px 0;
        }

        .design-note {
            background: #e0f2f1;
            padding: 15px;
            border-left: 5px solid #009688;
            border-radius: 5px;
            margin: 15px 0;
            font-size: 0.95em;
        }

        .pedagogical-note {
            background: #fff8e1;
            padding: 15px;
            border: 2px solid #ffb300;
            border-radius: 8px;
            margin: 20px 0;
        }

        .connection-box {
            background: #e1f5fe;
            padding: 15px;
            border-left: 5px solid #03a9f4;
            border-radius: 5px;
            margin: 15px 0;
        }

        /* Tablas */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        th {
            background-color: #8e44ad;
            color: white;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        /* C√≥digo */
        .code-container {
            position: relative;
        }

        .copy-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #9b59b6;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.3s;
            z-index: 10;
        }

        .copy-button:hover {
            background: #8e44ad;
        }

        .copy-button.copied {
            background: #3498db;
        }

        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            line-height: 1.5;
        }

        code {
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
        }

        /* IA prompts */
        .prompt-number {
            background: #9b59b6;
            color: white;
            padding: 6px 12px;
            border-radius: 50%;
            font-weight: bold;
            margin-right: 10px;
            display: inline-block;
        }

        .ia-prompt {
            background: #f8f9fa;
            padding: 15px;
            border: 2px dashed #9b59b6;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
        }

        /* Bot√≥n enlace */
        .btn-link {
            display: inline-block;
            padding: 10px 20px;
            background: #9b59b6;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin-top: 10px;
            font-weight: bold;
        }

        .btn-link:hover {
            background: #8e44ad;
        }

        /* Footer */
        footer {
            margin-top: 50px;
            text-align: center;
            font-size: 0.9em;
            color: #777;
            border-top: 1px solid #ddd;
            padding-top: 20px;
        }

        /* Responsividad */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            nav ul {
                flex-direction: column;
                align-items: center;
            }

            table {
                font-size: 0.9em;
            }

            h1 {
                font-size: 1.5em;
            }
        }

        /* Rotaciones y animaciones para √°rboles */
        .rotation-diagram {
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .rotation-step {
            text-align: center;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .arrow {
            font-size: 2em;
            color: #8e44ad;
        }

        details {
            margin: 10px 0;
        }

        details summary {
            cursor: pointer;
            font-weight: 600;
            color: #8e44ad;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 5px;
        }

        details summary:hover {
            background: #ede7f6;
        }

        details[open] summary {
            margin-bottom: 10px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({ startOnLoad: true, theme: 'default' });</script>
</head>
<body>
<div class="container">
    <h1>üå≤ Semana 8 ‚Äì Estructuras de Datos Arb√≥reas Especializadas</h1>
    <p><em>Estructuras de Datos Avanzadas ¬© 2025 | Unidad III. √Årboles y Estructuras Jer√°rquicas</em></p>

    <div class="pedagogical-note">
        <strong>üìö Nota de estudio:</strong> Esta semana cubre conceptos densos. Se recomienda:
        <ul>
            <li><strong>D√≠a 1-2:</strong> BST completo (inserci√≥n, b√∫squeda, eliminaci√≥n) + recorridos</li>
            <li><strong>D√≠a 3-4:</strong> Problema del desbalance + AVL (teor√≠a y rotaciones simples)</li>
            <li><strong>D√≠a 5:</strong> AVL rotaciones dobles + pr√°ctica con simulador</li>
            <li><strong>D√≠a 6-7:</strong> B+ y Huffman (enfoque conceptual, implementaci√≥n opcional)</li>
        </ul>
        <em>Los temas de B+ y Huffman son aplicaciones avanzadas; enf√≥cate primero en dominar BST y AVL.</em>
    </div>

    <nav>
        <ul>
            <li><a href="#intro">Introducci√≥n</a></li>
            <li><a href="#bst">3.3.1 BST</a></li>
            <li><a href="#recorridos">3.3.2 Recorridos</a></li>
            <li><a href="#desbalance">3.3.3 Desbalance</a></li>
            <li><a href="#avl">3.3.4 AVL</a></li>
            <li><a href="#bplus">3.3.5 √Årboles B+</a></li>
            <li><a href="#huffman">3.3.6 Huffman</a></li>
            <li><a href="#errores">Errores comunes</a></li>
            <li><a href="#codigo">C√≥digo Python</a></li>
            <li><a href="#ia-activities">Actividades con IA</a></li>
            <li><a href="#proyecto">Proyecto</a></li>
            <li><a href="#reto">Reto gamificado</a></li>
        </ul>
    </nav>

    <!-- INTRO / ENGANCHE -->
    <section id="intro">
        <div class="engage">
            <h3>‚ö° Actividad R√°pida (3 min)</h3>
            <p><strong>Imagina un diccionario con 1 mill√≥n de palabras.</strong> Si las guardas en una lista y buscas "zorro", tendr√≠as que revisar ¬øcu√°ntas palabras en promedio? ¬øY si las organizas como un √°rbol de b√∫squeda balanceado?</p>
            <details>
                <summary>üëâ Ver respuesta</summary>
                <p><strong>Lista desordenada:</strong> En promedio 500,000 comparaciones (O(n)).</p>
                <p><strong>Lista ordenada con b√∫squeda binaria:</strong> Aproximadamente 20 comparaciones (O(log n)).</p>
                <p><strong>√Årbol balanceado:</strong> Tambi√©n ~20 comparaciones, pero adem√°s permite inserciones y eliminaciones eficientes sin reordenar todo.</p>
                <p>Esta es la magia de los <strong>√°rboles de b√∫squeda balanceados</strong>: mantienen O(log n) incluso con operaciones din√°micas.</p>
            </details>
        </div>

        <h2>üéØ Objetivos de la Semana</h2>
        <div class="objectives">
            <ul>
                <li>Dominar los <strong>√°rboles binarios de b√∫squeda (BST)</strong> y sus operaciones fundamentales (insertar, buscar, <strong>eliminar</strong>).</li>
                <li>Aplicar las <strong>t√©cnicas de recorrido</strong> (inorden, preorden, postorden) y comprender su relaci√≥n con notaciones de expresiones.</li>
                <li>Comprender el <strong>problema del desbalance</strong> y su impacto en el rendimiento.</li>
                <li>Implementar <strong>√°rboles AVL</strong> con rotaciones para balanceo autom√°tico.</li>
                <li>Conocer los <strong>√°rboles B+</strong> y su aplicaci√≥n en bases de datos e indexaci√≥n.</li>
                <li>Construir <strong>√°rboles de Huffman</strong> para compresi√≥n de datos.</li>
                <li>Usar <strong>IA generativa de forma cr√≠tica</strong>, validando sus respuestas.</li>
            </ul>
        </div>
    </section>

    <!-- 3.3.1 BST -->
    <section id="bst">
        <h2>üîç 3.3.1 √Årboles Binarios de B√∫squeda: Fundamentos y Operaciones</h2>
        
        <div class="math-def">
            <strong>Propiedad BST (Invariante)</strong><br>
            Para todo nodo N: todos los valores en su sub√°rbol izquierdo son &lt; N.valor &lt; todos los valores en su sub√°rbol derecho
        </div>

        <div class="concepts">
            <h3>¬øQu√© es un BST?</h3>
            <ul>
                <li>√Årbol binario donde cada nodo tiene a lo m√°s <strong>dos hijos</strong>.</li>
                <li>La <strong>propiedad de ordenamiento</strong> permite b√∫squedas eficientes.</li>
                <li>Un recorrido <strong>inorden</strong> produce los elementos ordenados.</li>
                <li>Base para estructuras m√°s avanzadas (AVL, Rojo-Negro, Splay).</li>
            </ul>
        </div>

        <div class="design-note">
            <strong>üîß Decisi√≥n de dise√±o: Manejo de duplicados</strong><br>
            En esta implementaci√≥n, <strong>no permitimos duplicados</strong> (el BST act√∫a como un conjunto). En aplicaciones reales existen alternativas:
            <ul>
                <li><strong>Contador en el nodo:</strong> Cada nodo almacena cu√°ntas veces aparece el valor.</li>
                <li><strong>Inserci√≥n sistem√°tica:</strong> Los duplicados siempre van a la izquierda (o derecha).</li>
                <li><strong>Lista en el nodo:</strong> Cada nodo contiene una lista de elementos con la misma clave.</li>
            </ul>
            La elecci√≥n depende del caso de uso. Nuestra implementaci√≥n es adecuada para √≠ndices √∫nicos.
        </div>

        <div class="visualization">
            <h3>üé® Ejemplo de BST</h3>
            <div class="mermaid" data-alt="√Årbol binario de b√∫squeda">
            graph TD
                50((50)) --> 30((30))
                50 --> 70((70))
                30 --> 20((20))
                30 --> 40((40))
                70 --> 60((60))
                70 --> 80((80))
                
                style 50 fill:#9b59b6,stroke:#8e44ad,stroke-width:3px,color:#fff
                style 30 fill:#3498db,stroke:#2980b9,stroke-width:2px,color:#fff
                style 70 fill:#3498db,stroke:#2980b9,stroke-width:2px,color:#fff
            </div>
            <p><em>Observa: 30 &lt; 50 (izquierda), 70 &gt; 50 (derecha). El patr√≥n se repite recursivamente.</em></p>
        </div>

        <div class="concepts">
            <h3>Operaciones fundamentales</h3>
            <table>
                <tr>
                    <th>Operaci√≥n</th>
                    <th>Descripci√≥n</th>
                    <th>Complejidad (promedio)</th>
                    <th>Complejidad (peor caso)</th>
                </tr>
                <tr>
                    <td><strong>B√∫squeda</strong></td>
                    <td>Localizar un valor en el √°rbol</td>
                    <td>O(log n)</td>
                    <td>O(n) - √°rbol degenerado</td>
                </tr>
                <tr>
                    <td><strong>Inserci√≥n</strong></td>
                    <td>Agregar un nuevo nodo manteniendo la propiedad BST</td>
                    <td>O(log n)</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><strong>Eliminaci√≥n</strong></td>
                    <td>Remover un nodo preservando la estructura</td>
                    <td>O(log n)</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><strong>M√≠nimo/M√°ximo</strong></td>
                    <td>Encontrar extremos (ir siempre izq/der)</td>
                    <td>O(log n)</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><strong>Sucesor/Predecesor</strong></td>
                    <td>Siguiente/anterior elemento en orden</td>
                    <td>O(log n)</td>
                    <td>O(n)</td>
                </tr>
            </table>
        </div>

        <div class="algorithm-box">
            <h3>üìã Algoritmo de Inserci√≥n en BST</h3>
            <ol>
                <li>Si el √°rbol est√° vac√≠o, crear nodo ra√≠z con el valor.</li>
                <li>Si valor &lt; nodo actual, ir al sub√°rbol izquierdo.</li>
                <li>Si valor &gt; nodo actual, ir al sub√°rbol derecho.</li>
                <li>Repetir hasta encontrar una posici√≥n vac√≠a.</li>
                <li>Insertar el nuevo nodo en esa posici√≥n.</li>
            </ol>
        </div>

        <div class="algorithm-box">
            <h3>üìã Algoritmo de Eliminaci√≥n en BST (3 casos)</h3>
            <p><strong>Esta es la operaci√≥n m√°s compleja del BST.</strong> Debemos considerar tres casos:</p>
            <table>
                <tr>
                    <th>Caso</th>
                    <th>Situaci√≥n</th>
                    <th>Acci√≥n</th>
                    <th>Visualizaci√≥n</th>
                </tr>
                <tr>
                    <td><strong>1. Hoja</strong></td>
                    <td>Nodo sin hijos</td>
                    <td>Simplemente eliminarlo (desconectar del padre)</td>
                    <td>‚úÇÔ∏è Cortar enlace</td>
                </tr>
                <tr>
                    <td><strong>2. Un hijo</strong></td>
                    <td>Nodo con exactamente un hijo</td>
                    <td>Reemplazar el nodo con su √∫nico hijo (bypass)</td>
                    <td>üîó Reconectar padre con nieto</td>
                </tr>
                <tr>
                    <td><strong>3. Dos hijos</strong></td>
                    <td>Nodo con ambos hijos</td>
                    <td>
                        <ol>
                            <li>Encontrar el <strong>sucesor inorden</strong> (m√≠nimo del sub√°rbol derecho)</li>
                            <li>Copiar el valor del sucesor al nodo a eliminar</li>
                            <li>Eliminar el sucesor (que ser√° caso 1 o 2)</li>
                        </ol>
                    </td>
                    <td>üîÑ Sustituir y eliminar sucesor</td>
                </tr>
            </table>
        </div>

        <div class="visualization">
            <h3>üé¨ Ejemplo de eliminaci√≥n (Caso 3: dos hijos)</h3>
            <p>Eliminar el nodo <strong>50</strong> del siguiente √°rbol:</p>
            <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 20px;">
                <div class="rotation-step">
                    <p><strong>Antes</strong></p>
                    <div class="mermaid" data-alt="Antes de eliminar">
                    graph TD
                        E50((50)) --> E30((30))
                        E50 --> E70((70))
                        E30 --> E20((20))
                        E30 --> E40((40))
                        E70 --> E60((60))
                        E70 --> E80((80))
                        
                        style E50 fill:#e74c3c,stroke:#c0392b,stroke-width:3px,color:#fff
                        style E60 fill:#f39c12,stroke:#d68910,stroke-width:2px,color:#fff
                    </div>
                    <p><em>50 tiene dos hijos.<br>Sucesor inorden: 60</em></p>
                </div>
                <div class="arrow">‚Üí</div>
                <div class="rotation-step">
                    <p><strong>Despu√©s</strong></p>
                    <div class="mermaid" data-alt="Despu√©s de eliminar">
                    graph TD
                        F60((60)) --> F30((30))
                        F60 --> F70((70))
                        F30 --> F20((20))
                        F30 --> F40((40))
                        F70 --> F80((80))
                        
                        style F60 fill:#27ae60,stroke:#1e8449,stroke-width:3px,color:#fff
                    </div>
                    <p><em>60 reemplaza a 50.<br>El 60 original se elimina (era hoja).</em></p>
                </div>
            </div>
        </div>

        <div class="checkpoint">
            <h3>‚è∏Ô∏è Checkpoint conceptual</h3>
            <ol>
                <li>¬øPor qu√© un recorrido inorden de un BST produce una secuencia ordenada?</li>
                <li>Si insertas [50, 30, 70, 20, 40] en un BST vac√≠o, dibuja el √°rbol resultante.</li>
                <li>¬øQu√© pasa si insertas elementos ya ordenados [10, 20, 30, 40, 50]?</li>
            </ol>
            <details>
                <summary>üí° Ver respuestas sugeridas</summary>
                <div style="padding: 15px; background: #f9f9f9; border-radius: 5px;">
                    <p><strong>1.</strong> Porque inorden visita: izquierda ‚Üí nodo ‚Üí derecha. En un BST, todos los valores de la izquierda son menores que el nodo, y todos los de la derecha son mayores. Al visitar en ese orden, se procesan de menor a mayor.</p>
                    <p><strong>2.</strong> El √°rbol resultante:</p>
                    <pre>
        50
       /  \
      30   70
     /  \
    20  40</pre>
                    <p><strong>3.</strong> Se forma un √°rbol degenerado (lista enlazada hacia la derecha). Cada nuevo elemento es mayor que todos los anteriores, as√≠ que siempre va a la derecha. Altura = n-1, rendimiento O(n).</p>
                </div>
            </details>
        </div>
    </section>

    <!-- 3.3.2 RECORRIDOS -->
    <section id="recorridos">
        <h2>üö∂ 3.3.2 T√©cnicas de Recorrido y Procesamiento de Expresiones</h2>

        <div class="concepts">
            <h3>Los tres recorridos cl√°sicos (DFS)</h3>
            <table>
                <tr>
                    <th>Recorrido</th>
                    <th>Orden de visita</th>
                    <th>Aplicaci√≥n principal</th>
                    <th>Mnemot√©cnico</th>
                </tr>
                <tr>
                    <td><strong>Inorden (LNR)</strong></td>
                    <td>Izquierda ‚Üí Nodo ‚Üí Derecha</td>
                    <td>Obtener elementos ordenados en BST</td>
                    <td>"El nodo en medio"</td>
                </tr>
                <tr>
                    <td><strong>Preorden (NLR)</strong></td>
                    <td>Nodo ‚Üí Izquierda ‚Üí Derecha</td>
                    <td>Copiar/serializar √°rbol, notaci√≥n prefija</td>
                    <td>"Nodo primero"</td>
                </tr>
                <tr>
                    <td><strong>Postorden (LRN)</strong></td>
                    <td>Izquierda ‚Üí Derecha ‚Üí Nodo</td>
                    <td>Eliminar √°rbol, notaci√≥n postfija (RPN)</td>
                    <td>"Nodo al final"</td>
                </tr>
            </table>
        </div>

        <div class="visualization">
            <h3>üé¨ Ejemplo de los tres recorridos</h3>
            <div class="mermaid" data-alt="√Årbol de expresi√≥n">
            graph TD
                MULT((*)) --> PLUS((+))
                MULT --> C((C))
                PLUS --> A((A))
                PLUS --> B((B))
                
                style MULT fill:#e74c3c,stroke:#c0392b,stroke-width:3px,color:#fff
                style PLUS fill:#f39c12,stroke:#d68910,stroke-width:2px,color:#fff
            </div>
            <p>√Årbol que representa la expresi√≥n <strong>(A + B) * C</strong></p>
            <table>
                <tr>
                    <th>Recorrido</th>
                    <th>Resultado</th>
                    <th>Interpretaci√≥n</th>
                </tr>
                <tr>
                    <td>Inorden</td>
                    <td>A + B * C</td>
                    <td>Notaci√≥n infija (necesita par√©ntesis para claridad)</td>
                </tr>
                <tr>
                    <td>Preorden</td>
                    <td>* + A B C</td>
                    <td>Notaci√≥n prefija (polaca) - no necesita par√©ntesis</td>
                </tr>
                <tr>
                    <td>Postorden</td>
                    <td>A B + C *</td>
                    <td>Notaci√≥n postfija (RPN) - ideal para evaluaci√≥n con pila</td>
                </tr>
            </table>
        </div>

        <div class="connection-box">
            <h3>üîó Conexi√≥n clave: √Årbol ‚Üí Recorrido ‚Üí Pila</h3>
            <p><strong>El recorrido postorden de un √°rbol de expresi√≥n genera exactamente la notaci√≥n polaca inversa (RPN)</strong>, la cual puede ser evaluada linealmente usando una pila.</p>
            <p>Es decir:</p>
            <ol>
                <li>Un <strong>√°rbol de expresi√≥n</strong> representa la estructura jer√°rquica de una f√≥rmula.</li>
                <li>El <strong>recorrido postorden</strong> produce una secuencia lineal (RPN).</li>
                <li>Un <strong>algoritmo con pila</strong> eval√∫a esa secuencia eficientemente.</li>
            </ol>
            <p><em>Esta es la raz√≥n por la que las calculadoras HP usan RPN: es m√°s f√°cil de procesar computacionalmente.</em></p>
        </div>

        <div class="application">
            <h3>üí° Aplicaci√≥n: Evaluaci√≥n de expresiones con pila</h3>
            <p>La notaci√≥n postfija permite evaluar expresiones sin par√©ntesis usando una pila:</p>
            <ol>
                <li>Lee tokens de izquierda a derecha.</li>
                <li>Si es operando: push a la pila.</li>
                <li>Si es operador: pop dos operandos, aplica operador, push resultado.</li>
                <li>Al final, el resultado est√° en el tope de la pila.</li>
            </ol>
            <p><strong>Ejemplo:</strong> Evaluar <code>3 4 + 2 *</code></p>
            <table>
                <tr>
                    <th>Token</th>
                    <th>Acci√≥n</th>
                    <th>Pila</th>
                </tr>
                <tr><td>3</td><td>push</td><td>[3]</td></tr>
                <tr><td>4</td><td>push</td><td>[3, 4]</td></tr>
                <tr><td>+</td><td>pop 4, pop 3, push 3+4=7</td><td>[7]</td></tr>
                <tr><td>2</td><td>push</td><td>[7, 2]</td></tr>
                <tr><td>*</td><td>pop 2, pop 7, push 7*2=14</td><td>[14]</td></tr>
            </table>
            <p><strong>Resultado: 14</strong></p>
        </div>

        <div class="concepts">
            <h3>Recorrido por niveles (BFS)</h3>
            <p>Adem√°s de los recorridos DFS (profundidad), existe el recorrido por <strong>niveles</strong> o <strong>amplitud</strong>:</p>
            <ul>
                <li>Usa una <strong>cola</strong> en lugar de recursi√≥n/pila.</li>
                <li>Visita todos los nodos del nivel k antes de pasar al nivel k+1.</li>
                <li>√ötil para: encontrar profundidad, imprimir √°rbol por niveles, encontrar camino m√°s corto.</li>
            </ul>
        </div>

        <div class="checkpoint">
            <h3>‚è∏Ô∏è Checkpoint conceptual</h3>
            <ol>
                <li>Si tienes la expresi√≥n <code>(2 + 3) * (4 - 1)</code>, ¬øcu√°l es su forma postfija?</li>
                <li>¬øQu√© recorrido usar√≠as para hacer una copia exacta de un √°rbol?</li>
                <li>En un √°rbol de expresi√≥n, ¬ød√≥nde est√°n los operandos y d√≥nde los operadores?</li>
            </ol>
            <details>
                <summary>üí° Ver respuestas sugeridas</summary>
                <div style="padding: 15px; background: #f9f9f9; border-radius: 5px;">
                    <p><strong>1.</strong> <code>2 3 + 4 1 - *</code>. Primero se eval√∫a 2+3=5, luego 4-1=3, finalmente 5*3=15.</p>
                    <p><strong>2.</strong> Preorden (NLR). Al procesar el nodo antes que sus hijos, puedes crear el nodo copia y luego recursivamente copiar sus sub√°rboles.</p>
                    <p><strong>3.</strong> Los operandos siempre son hojas (no tienen hijos). Los operadores son nodos internos (tienen al menos un hijo, usualmente dos para operadores binarios).</p>
                </div>
            </details>
        </div>
    </section>

    <!-- 3.3.3 DESBALANCE -->
    <section id="desbalance">
        <h2>‚ö†Ô∏è 3.3.3 Problema del Desbalance y Necesidad de Equilibrio</h2>

        <div class="warning">
            <h3>El enemigo silencioso: el √°rbol degenerado</h3>
            <p>Si insertas elementos ordenados en un BST, obtienes una <strong>lista enlazada</strong> disfrazada de √°rbol. Todas las operaciones pasan de O(log n) a O(n).</p>
        </div>

        <div class="visualization">
            <h3>Comparaci√≥n visual: balanceado vs degenerado</h3>
            <div style="display: flex; justify-content: space-around; flex-wrap: wrap;">
                <div>
                    <h4>BST Balanceado (inserci√≥n: 50, 25, 75, 10, 30)</h4>
                    <div class="mermaid" data-alt="√Årbol balanceado">
                    graph TD
                        A50((50)) --> A25((25))
                        A50 --> A75((75))
                        A25 --> A10((10))
                        A25 --> A30((30))
                        
                        style A50 fill:#27ae60,stroke:#1e8449,stroke-width:3px,color:#fff
                    </div>
                    <p style="text-align:center;"><strong>Altura: 2</strong> ‚Üí O(log n)</p>
                </div>
                <div>
                    <h4>BST Degenerado (inserci√≥n: 10, 20, 30, 40, 50)</h4>
                    <div class="mermaid" data-alt="√Årbol degenerado">
                    graph TD
                        B10((10)) --> B20((20))
                        B20 --> B30((30))
                        B30 --> B40((40))
                        B40 --> B50((50))
                        
                        style B10 fill:#e74c3c,stroke:#c0392b,stroke-width:3px,color:#fff
                    </div>
                    <p style="text-align:center;"><strong>Altura: 4</strong> ‚Üí O(n)</p>
                </div>
            </div>
        </div>

        <div class="math-def">
            <strong>Factor de Balance (FB)</strong><br>
            FB(nodo) = altura(sub√°rbol izquierdo) ‚àí altura(sub√°rbol derecho)<br>
            √Årbol balanceado: |FB| ‚â§ 1 para todos los nodos
        </div>

        <div class="concepts">
            <h3>Impacto del desbalance en el rendimiento</h3>
            <table>
                <tr>
                    <th>Escenario</th>
                    <th>Altura del √°rbol</th>
                    <th>B√∫squeda (n = 1,000,000)</th>
                </tr>
                <tr>
                    <td>BST perfectamente balanceado</td>
                    <td>‚åälog‚ÇÇ n‚åã ‚âà 20</td>
                    <td>~20 comparaciones</td>
                </tr>
                <tr>
                    <td>BST AVL (casi balanceado)</td>
                    <td>‚â§ 1.44 log‚ÇÇ n ‚âà 29</td>
                    <td>~29 comparaciones</td>
                </tr>
                <tr>
                    <td>BST degenerado (lista)</td>
                    <td>n - 1 = 999,999</td>
                    <td>~500,000 comparaciones promedio</td>
                </tr>
            </table>
        </div>

        <div class="concepts">
            <h3>Soluciones al problema del desbalance</h3>
            <table>
                <tr>
                    <th>Estrategia</th>
                    <th>Estructura</th>
                    <th>Garant√≠a</th>
                </tr>
                <tr>
                    <td>Balanceo estricto por altura</td>
                    <td><strong>√Årboles AVL</strong></td>
                    <td>|FB| ‚â§ 1, altura ‚â§ 1.44 log n</td>
                </tr>
                <tr>
                    <td>Balanceo por color (menos rotaciones)</td>
                    <td><strong>√Årboles Rojo-Negro</strong></td>
                    <td>altura ‚â§ 2 log n</td>
                </tr>
                <tr>
                    <td>Auto-ajuste por acceso</td>
                    <td><strong>√Årboles Splay</strong></td>
                    <td>O(log n) amortizado</td>
                </tr>
                <tr>
                    <td>Aleatorizaci√≥n</td>
                    <td><strong>Treaps</strong></td>
                    <td>O(log n) esperado</td>
                </tr>
            </table>
        </div>

        <div class="checkpoint">
            <h3>‚è∏Ô∏è Checkpoint conceptual</h3>
            <ol>
                <li>¬øPor qu√© la inserci√≥n ordenada causa el peor caso en un BST?</li>
                <li>Calcula el factor de balance de cada nodo en un √°rbol con ra√≠z 50, hijo izquierdo 30, hijo derecho 70.</li>
                <li>¬øQu√© ventaja tiene un √°rbol Rojo-Negro sobre un AVL? ¬øY viceversa?</li>
            </ol>
            <details>
                <summary>üí° Ver respuestas sugeridas</summary>
                <div style="padding: 15px; background: #f9f9f9; border-radius: 5px;">
                    <p><strong>1.</strong> Porque cada nuevo elemento es mayor (o menor) que todos los anteriores, siempre va al mismo lado (derecha o izquierda), creando una cadena lineal.</p>
                    <p><strong>2.</strong> FB(50) = altura(30) - altura(70) = 1 - 1 = 0. FB(30) = 0 - 0 = 0. FB(70) = 0 - 0 = 0. Todos balanceados.</p>
                    <p><strong>3.</strong> Rojo-Negro: menos rotaciones en promedio (mejor para muchas inserciones/eliminaciones). AVL: m√°s estrictamente balanceado (mejor para muchas b√∫squedas). En la pr√°ctica, Rojo-Negro es m√°s com√∫n en bibliotecas est√°ndar (std::map en C++, TreeMap en Java).</p>
                </div>
            </details>
        </div>
    </section>

    <!-- 3.3.4 AVL -->
    <section id="avl">
        <h2>‚öñÔ∏è 3.3.4 √Årboles AVL: Balanceo Autom√°tico</h2>

        <div class="concepts">
            <h3>¬øQu√© es un √°rbol AVL?</h3>
            <p>Nombrado por sus inventores <strong>A</strong>delson-<strong>V</strong>elsky y <strong>L</strong>andis (1962), es un BST que mantiene autom√°ticamente el balance mediante <strong>rotaciones</strong>.</p>
            <ul>
                <li>Invariante: Para cada nodo, |FB| ‚â§ 1.</li>
                <li>Garantiza altura O(log n).</li>
                <li>Cada inserci√≥n o eliminaci√≥n puede requerir rotaciones para restaurar el balance.</li>
            </ul>
        </div>

        <div class="math-def">
            <strong>Altura m√°xima de un AVL</strong><br>
            h(n) ‚â§ 1.44 ¬∑ log‚ÇÇ(n + 2) ‚àí 0.328<br>
            Para n = 1,000,000: h ‚â§ 29 (vs 20 para √°rbol perfecto, vs 999,999 para degenerado)
        </div>

        <div class="algorithm-box">
            <h3>üìã Las 4 rotaciones del AVL</h3>
            <p>Cuando |FB| > 1, se aplica una rotaci√≥n seg√∫n el patr√≥n de desbalance:</p>
            <table>
                <tr>
                    <th>Caso</th>
                    <th>Patr√≥n</th>
                    <th>FB del nodo</th>
                    <th>FB del hijo</th>
                    <th>Rotaci√≥n</th>
                </tr>
                <tr>
                    <td><strong>LL</strong></td>
                    <td>Inserci√≥n en sub√°rbol izquierdo del hijo izquierdo</td>
                    <td>+2</td>
                    <td>+1 o 0</td>
                    <td>Rotaci√≥n simple derecha</td>
                </tr>
                <tr>
                    <td><strong>RR</strong></td>
                    <td>Inserci√≥n en sub√°rbol derecho del hijo derecho</td>
                    <td>-2</td>
                    <td>-1 o 0</td>
                    <td>Rotaci√≥n simple izquierda</td>
                </tr>
                <tr>
                    <td><strong>LR</strong></td>
                    <td>Inserci√≥n en sub√°rbol derecho del hijo izquierdo</td>
                    <td>+2</td>
                    <td>-1</td>
                    <td>Rotaci√≥n doble: izquierda + derecha</td>
                </tr>
                <tr>
                    <td><strong>RL</strong></td>
                    <td>Inserci√≥n en sub√°rbol izquierdo del hijo derecho</td>
                    <td>-2</td>
                    <td>+1</td>
                    <td>Rotaci√≥n doble: derecha + izquierda</td>
                </tr>
            </table>
        </div>

        <div class="visualization">
            <h3>üé¨ Rotaci√≥n simple a la derecha (caso LL)</h3>
            <div style="display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 30px;">
                <div class="rotation-step">
                    <p><strong>Antes (desbalanceado)</strong></p>
                    <div class="mermaid" data-alt="Antes de rotaci√≥n">
                    graph TD
                        Z((Z<br>FB=+2)) --> Y((Y<br>FB=+1))
                        Z --> T4[T4]
                        Y --> X((X))
                        Y --> T3[T3]
                        X --> T1[T1]
                        X --> T2[T2]
                        
                        style Z fill:#e74c3c,stroke:#c0392b,color:#fff
                        style Y fill:#f39c12,stroke:#d68910,color:#fff
                    </div>
                </div>
                <div class="arrow">‚Üí</div>
                <div class="rotation-step">
                    <p><strong>Despu√©s (balanceado)</strong></p>
                    <div class="mermaid" data-alt="Despu√©s de rotaci√≥n">
                    graph TD
                        Y2((Y<br>FB=0)) --> X2((X))
                        Y2 --> Z2((Z<br>FB=0))
                        X2 --> T1b[T1]
                        X2 --> T2b[T2]
                        Z2 --> T3b[T3]
                        Z2 --> T4b[T4]
                        
                        style Y2 fill:#27ae60,stroke:#1e8449,color:#fff
                        style Z2 fill:#27ae60,stroke:#1e8449,color:#fff
                    </div>
                </div>
            </div>
            <p style="text-align: center;"><em>Y "sube" a la ra√≠z, Z "baja" a la derecha, T3 cambia de padre (de Y a Z)</em></p>
        </div>

        <div class="visualization">
            <h3>üé¨ Rotaci√≥n doble LR (en 3 pasos)</h3>
            <p>La rotaci√≥n doble se entiende mejor como <strong>dos rotaciones simples consecutivas</strong>:</p>
            <div style="display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 15px;">
                <div class="rotation-step">
                    <p><strong>1. Estado inicial</strong></p>
                    <div class="mermaid" data-alt="Estado inicial LR">
                    graph TD
                        Z1((Z<br>FB=+2)) --> Y1((Y<br>FB=-1))
                        Z1 --> T4a[T4]
                        Y1 --> T1a[T1]
                        Y1 --> X1((X))
                        X1 --> T2a[T2]
                        X1 --> T3a[T3]
                        
                        style Z1 fill:#e74c3c,color:#fff
                        style Y1 fill:#f39c12,color:#fff
                        style X1 fill:#3498db,color:#fff
                    </div>
                    <p><em>Z tiene FB=+2<br>pero Y tiene FB=-1 (caso LR)</em></p>
                </div>
                <div class="arrow">‚Üí</div>
                <div class="rotation-step">
                    <p><strong>2. Rotaci√≥n izquierda en Y</strong></p>
                    <div class="mermaid" data-alt="Despu√©s de rotaci√≥n izquierda">
                    graph TD
                        Z2((Z<br>FB=+2)) --> X2((X))
                        Z2 --> T4b[T4]
                        X2 --> Y2((Y))
                        X2 --> T3b[T3]
                        Y2 --> T1b[T1]
                        Y2 --> T2b[T2]
                        
                        style Z2 fill:#e74c3c,color:#fff
                        style X2 fill:#3498db,color:#fff
                    </div>
                    <p><em>Ahora es caso LL puro<br>(FB de hijo es +1)</em></p>
                </div>
                <div class="arrow">‚Üí</div>
                <div class="rotation-step">
                    <p><strong>3. Rotaci√≥n derecha en Z</strong></p>
                    <div class="mermaid" data-alt="Estado final balanceado">
                    graph TD
                        X3((X<br>FB=0)) --> Y3((Y))
                        X3 --> Z3((Z))
                        Y3 --> T1c[T1]
                        Y3 --> T2c[T2]
                        Z3 --> T3c[T3]
                        Z3 --> T4c[T4]
                        
                        style X3 fill:#27ae60,color:#fff
                        style Y3 fill:#27ae60,color:#fff
                        style Z3 fill:#27ae60,color:#fff
                    </div>
                    <p><em>¬°Balanceado!<br>X es la nueva ra√≠z</em></p>
                </div>
            </div>
        </div>

        <div class="concepts">
            <h3>Complejidad de operaciones AVL</h3>
            <table>
                <tr>
                    <th>Operaci√≥n</th>
                    <th>Complejidad</th>
                    <th>Rotaciones m√°ximas</th>
                </tr>
                <tr>
                    <td>B√∫squeda</td>
                    <td>O(log n)</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>Inserci√≥n</td>
                    <td>O(log n)</td>
                    <td>‚â§ 2 (una simple o una doble)</td>
                </tr>
                <tr>
                    <td>Eliminaci√≥n</td>
                    <td>O(log n)</td>
                    <td>O(log n) en el peor caso</td>
                </tr>
            </table>
        </div>

        <div class="visualization">
            <h3>üîß Simulador interactivo recomendado</h3>
            <p>Practica inserciones y rotaciones visualmente:</p>
            <a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html" target="_blank" class="btn-link">
                üëâ Simulador AVL (USFCA)
            </a>
            <p><em>Recomendaci√≥n: Inserta la secuencia 30, 20, 10 para ver una rotaci√≥n LL, luego 40, 50 para ver RR, luego 25 para ver LR.</em></p>
        </div>

        <div class="checkpoint">
            <h3>‚è∏Ô∏è Checkpoint conceptual</h3>
            <ol>
                <li>¬øPor qu√© despu√©s de una inserci√≥n en AVL solo se necesitan como m√°ximo 2 rotaciones?</li>
                <li>Si insertas [30, 20, 25] en un AVL vac√≠o, ¬øqu√© tipo de rotaci√≥n ocurre?</li>
                <li>¬øCu√°l es la diferencia entre el FB del nodo desbalanceado y el FB de su hijo para distinguir LL de LR?</li>
            </ol>
            <details>
                <summary>üí° Ver respuestas sugeridas</summary>
                <div style="padding: 15px; background: #f9f9f9; border-radius: 5px;">
                    <p><strong>1.</strong> Porque una inserci√≥n aumenta la altura de un sub√°rbol en m√°ximo 1. Una rotaci√≥n (simple o doble) reduce esa altura en 1, restaurando el balance. No puede quedar otro nodo desbalanceado arriba porque el sub√°rbol rotado ahora tiene la misma altura que antes de la inserci√≥n.</p>
                    <p><strong>2.</strong> Rotaci√≥n doble LR. Despu√©s de [30, 20]: 30 tiene hijo izquierdo 20. Al insertar 25: va a la derecha de 20 (FB de 30 = +2, FB de 20 = -1). Caso LR.</p>
                    <p><strong>3.</strong> En LL: FB(nodo)=+2 y FB(hijo izq)=+1 o 0 (mismo signo). En LR: FB(nodo)=+2 pero FB(hijo izq)=-1 (signos opuestos). El signo opuesto indica que hay un "zigzag" que requiere doble rotaci√≥n.</p>
                </div>
            </details>
        </div>
    </section>

    <!-- 3.3.5 B+ -->
    <section id="bplus">
        <h2>üíæ 3.3.5 √Årboles B+: Optimizaci√≥n para Almacenamiento Masivo</h2>

        <div class="pedagogical-note">
            <strong>üìå Nivel de profundidad:</strong> Esta secci√≥n es conceptual. La implementaci√≥n de B+ es compleja y generalmente se deja para cursos de bases de datos. Enf√≥cate en entender <em>por qu√©</em> existen y <em>cu√°ndo</em> usarlos.
        </div>

        <div class="concepts">
            <h3>¬øPor qu√© no usar AVL en bases de datos?</h3>
            <p>Los √°rboles binarios tienen un problema fundamental para almacenamiento en disco:</p>
            <ul>
                <li>Cada acceso a un nodo puede requerir un <strong>acceso a disco</strong>.</li>
                <li>Un disco puede leer ~100-200 operaciones/segundo vs ~10‚Åπ en RAM.</li>
                <li>Un AVL con 1 mill√≥n de elementos necesita ~20 accesos a disco por b√∫squeda.</li>
                <li><strong>Soluci√≥n:</strong> Nodos m√°s grandes que almacenen m√∫ltiples claves ‚Üí menos niveles ‚Üí menos accesos a disco.</li>
            </ul>
        </div>

        <div class="math-def">
            <strong>Definici√≥n de √Årbol B+ de orden m</strong><br>
            ‚Ä¢ Cada nodo interno tiene entre ‚åàm/2‚åâ y m hijos<br>
            ‚Ä¢ La ra√≠z tiene entre 2 y m hijos (si no es hoja)<br>
            ‚Ä¢ Todas las hojas est√°n al mismo nivel<br>
            ‚Ä¢ Las hojas contienen todos los datos y est√°n enlazadas secuencialmente
        </div>

        <div class="visualization">
            <h3>üé® Estructura de un √°rbol B+ (orden 4)</h3>
            <div class="mermaid" data-alt="√Årbol B+ de orden 4">
            graph TD
                R["üîë √çNDICE<br>[30 | 60]"] --> N1["üîë √çNDICE<br>[10 | 20]"]
                R --> N2["üîë √çNDICE<br>[40 | 50]"]
                R --> N3["üîë √çNDICE<br>[70 | 80 | 90]"]
                
                N1 --> L1["üìÑ DATA<br>10 ‚Üí reg"]
                N1 --> L2["üìÑ DATA<br>20 ‚Üí reg"]
                N1 --> L3["üìÑ DATA<br>30 ‚Üí reg"]
                
                N2 --> L4["üìÑ DATA<br>40 ‚Üí reg"]
                N2 --> L5["üìÑ DATA<br>50 ‚Üí reg"]
                N2 --> L6["üìÑ DATA<br>60 ‚Üí reg"]
                
                N3 --> L7["üìÑ DATA<br>70 ‚Üí reg"]
                N3 --> L8["üìÑ DATA<br>80 ‚Üí reg"]
                N3 --> L9["üìÑ DATA<br>90 ‚Üí reg"]
                
                L1 -.->|siguiente| L2
                L2 -.->|siguiente| L3
                L3 -.->|siguiente| L4
                L4 -.->|siguiente| L5
                L5 -.->|siguiente| L6
                L6 -.->|siguiente| L7
                L7 -.->|siguiente| L8
                L8 -.->|siguiente| L9
                
                style R fill:#9b59b6,color:#fff
                style N1 fill:#3498db,color:#fff
                style N2 fill:#3498db,color:#fff
                style N3 fill:#3498db,color:#fff
                style L1 fill:#27ae60,color:#fff
                style L2 fill:#27ae60,color:#fff
                style L3 fill:#27ae60,color:#fff
                style L4 fill:#27ae60,color:#fff
                style L5 fill:#27ae60,color:#fff
                style L6 fill:#27ae60,color:#fff
                style L7 fill:#27ae60,color:#fff
                style L8 fill:#27ae60,color:#fff
                style L9 fill:#27ae60,color:#fff
            </div>
            <p><strong>Leyenda:</strong></p>
            <ul>
                <li>üîë <strong>Nodos √≠ndice (azul/morado):</strong> Solo contienen claves para navegaci√≥n, NO datos reales.</li>
                <li>üìÑ <strong>Hojas (verde):</strong> Contienen los datos reales (o punteros a registros). Est√°n enlazadas.</li>
                <li>Las l√≠neas punteadas muestran el <strong>enlace entre hojas</strong> para recorrido secuencial.</li>
            </ul>
            
            <div class="design-note">
                <strong>üí° Detalle de implementaci√≥n real:</strong> En el diagrama, el salto de L3 ‚Üí L4 implica cambiar de una "p√°gina" de disco a otra (L1-L3 pertenecen al bloque del nodo N1, mientras L4-L6 pertenecen al bloque de N2). Gracias al puntero "siguiente", este salto es <strong>directo</strong> (un solo acceso a disco), sin necesidad de volver a subir por los nodos √≠ndice. Esta es la gran ventaja de B+ para consultas de rango como <code>SELECT * WHERE precio BETWEEN 10 AND 50</code>.
            </div>
        </div>

        <div class="comparison">
            <h3>B-Tree vs B+ Tree</h3>
            <table>
                <tr>
                    <th>Caracter√≠stica</th>
                    <th>B-Tree</th>
                    <th>B+ Tree</th>
                </tr>
                <tr>
                    <td>Datos almacenados en</td>
                    <td>Todos los nodos</td>
                    <td><strong>Solo en hojas</strong></td>
                </tr>
                <tr>
                    <td>Claves duplicadas</td>
                    <td>No</td>
                    <td>S√≠ (en nodos internos como gu√≠as)</td>
                </tr>
                <tr>
                    <td>Hojas enlazadas</td>
                    <td>No</td>
                    <td><strong>S√≠ (lista enlazada)</strong></td>
                </tr>
                <tr>
                    <td>Recorrido secuencial</td>
                    <td>Requiere recorrido inorden</td>
                    <td><strong>Muy eficiente (seguir punteros)</strong></td>
                </tr>
                <tr>
                    <td>Uso t√≠pico</td>
                    <td>Sistemas de archivos</td>
                    <td><strong>√çndices de bases de datos</strong></td>
                </tr>
            </table>
        </div>

        <div class="application">
            <h3>üí° Aplicaciones de √Årboles B+</h3>
            <ul>
                <li><strong>MySQL (InnoDB):</strong> Todos los √≠ndices son √°rboles B+.</li>
                <li><strong>PostgreSQL:</strong> √çndices B-tree (variante de B+).</li>
                <li><strong>SQLite:</strong> Usa B-tree para tablas e √≠ndices.</li>
                <li><strong>Sistemas de archivos:</strong> NTFS, ext4, HFS+ usan variantes de B-tree.</li>
            </ul>
        </div>

        <div class="concepts">
            <h3>C√°lculo de altura y accesos a disco</h3>
            <p>Para un B+ de orden m con n claves:</p>
            <div class="math-def">
                altura ‚â§ ‚åàlog<sub>‚åàm/2‚åâ</sub>(n)‚åâ
            </div>
            <table>
                <tr>
                    <th>Estructura</th>
                    <th>Orden</th>
                    <th>Claves (n)</th>
                    <th>Altura</th>
                    <th>Accesos a disco</th>
                </tr>
                <tr>
                    <td>AVL</td>
                    <td>2</td>
                    <td>1,000,000</td>
                    <td>~20</td>
                    <td>~20</td>
                </tr>
                <tr>
                    <td>B+ (orden 100)</td>
                    <td>100</td>
                    <td>1,000,000</td>
                    <td>~3</td>
                    <td><strong>~3</strong></td>
                </tr>
                <tr>
                    <td>B+ (orden 500)</td>
                    <td>500</td>
                    <td>1,000,000</td>
                    <td>~2</td>
                    <td><strong>~2</strong></td>
                </tr>
            </table>
            <p><em>¬°Un B+ de orden 500 reduce los accesos a disco de 20 a solo 2!</em></p>
        </div>

        <div class="checkpoint">
            <h3>‚è∏Ô∏è Checkpoint conceptual</h3>
            <ol>
                <li>¬øPor qu√© las hojas de un B+ est√°n enlazadas?</li>
                <li>Si un nodo de B+ cabe en un bloque de disco de 4KB y cada clave ocupa 8 bytes, ¬øcu√°ntas claves puede tener aproximadamente?</li>
                <li>¬øPor qu√© un B+ es mejor que un AVL para consultas de rango (ej: "todos los productos con precio entre $10 y $50")?</li>
            </ol>
            <details>
                <summary>üí° Ver respuestas sugeridas</summary>
                <div style="padding: 15px; background: #f9f9f9; border-radius: 5px;">
                    <p><strong>1.</strong> Para permitir recorridos secuenciales eficientes. Una vez que llegas a la primera hoja del rango, puedes seguir los punteros sin volver a subir por el √°rbol.</p>
                    <p><strong>2.</strong> Aproximadamente 4096/8 ‚âà 500 claves por nodo (en realidad menos porque tambi√©n hay punteros, pero el orden de magnitud es correcto).</p>
                    <p><strong>3.</strong> En AVL tendr√≠as que hacer un recorrido inorden navegando arriba y abajo. En B+ encuentras la hoja con el primer valor del rango y luego solo sigues el enlace entre hojas hasta el final del rango. Mucho m√°s eficiente.</p>
                </div>
            </details>
        </div>
    </section>

    <!-- 3.3.6 HUFFMAN -->
    <section id="huffman">
        <h2>üì¶ 3.3.6 √Årboles de Huffman: Compresi√≥n de Datos</h2>

        <div class="pedagogical-note">
            <strong>üìå Nivel de profundidad:</strong> Huffman es un algoritmo elegante y accesible. Recomendamos implementarlo completamente como ejercicio de pr√°ctica con colas de prioridad y √°rboles.
        </div>

        <div class="concepts">
            <h3>El problema de la codificaci√≥n</h3>
            <p>Si usamos c√≥digos de longitud fija (como ASCII con 8 bits), desperdiciamos espacio en caracteres frecuentes.</p>
            <p><strong>Idea de Huffman (1952):</strong> Asignar c√≥digos m√°s cortos a s√≠mbolos m√°s frecuentes.</p>
        </div>

        <div class="math-def">
            <strong>Propiedad del c√≥digo prefijo</strong><br>
            Ning√∫n c√≥digo es prefijo de otro ‚Üí decodificaci√≥n √∫nica sin delimitadores<br>
            Ejemplo v√°lido: {0, 10, 110, 111} | Ejemplo inv√°lido: {0, 01, 10} (0 es prefijo de 01)
        </div>

        <div class="algorithm-box">
            <h3>üìã Algoritmo de Huffman</h3>
            <ol>
                <li>Calcular la frecuencia de cada s√≠mbolo.</li>
                <li>Crear un nodo hoja para cada s√≠mbolo con su frecuencia.</li>
                <li>Insertar todos los nodos en una <strong>cola de prioridad</strong> (min-heap por frecuencia).</li>
                <li><strong>Repetir</strong> mientras haya m√°s de un nodo:
                    <ul>
                        <li>Extraer los dos nodos con menor frecuencia.</li>
                        <li>Crear un nuevo nodo padre con frecuencia = suma de los dos.</li>
                        <li>Los dos nodos extra√≠dos se vuelven hijos del nuevo nodo.</li>
                        <li>Insertar el nuevo nodo en la cola.</li>
                    </ul>
                </li>
                <li>El nodo restante es la ra√≠z del √°rbol de Huffman.</li>
                <li>Asignar '0' a ramas izquierdas, '1' a ramas derechas.</li>
            </ol>
        </div>

        <div class="visualization">
            <h3>üé¨ Ejemplo: Construir √°rbol de Huffman</h3>
            <p>Texto: "ABRACADABRA" ‚Üí Frecuencias: A=5, B=2, R=2, C=1, D=1</p>
            
            <details>
                <summary>Ver construcci√≥n paso a paso</summary>
                <table>
                    <tr>
                        <th>Paso</th>
                        <th>Cola de prioridad</th>
                        <th>Acci√≥n</th>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td>C:1, D:1, B:2, R:2, A:5</td>
                        <td>Inicializar</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>B:2, R:2, (CD):2, A:5</td>
                        <td>Combinar C+D ‚Üí (CD):2</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>(CD):2, A:5, (BR):4</td>
                        <td>Combinar B+R ‚Üí (BR):4</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>(BR):4, (CD-A):7</td>
                        <td>Combinar (CD)+A ‚Üí 7</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>Ra√≠z:11</td>
                        <td>Combinar (BR)+(CD-A) ‚Üí Ra√≠z</td>
                    </tr>
                </table>
            </details>

            <div class="mermaid" data-alt="√Årbol de Huffman para ABRACADABRA">
            graph TD
                ROOT((11)) -->|0| BR((4))
                ROOT -->|1| CDA((7))
                BR -->|0| B["B:2<br>c√≥digo: 00"]
                BR -->|1| R["R:2<br>c√≥digo: 01"]
                CDA -->|0| CD((2))
                CDA -->|1| A["A:5<br>c√≥digo: 11"]
                CD -->|0| C["C:1<br>c√≥digo: 100"]
                CD -->|1| D["D:1<br>c√≥digo: 101"]
                
                style ROOT fill:#9b59b6,color:#fff
                style A fill:#27ae60,color:#fff
                style B fill:#3498db,color:#fff
                style R fill:#3498db,color:#fff
                style C fill:#f39c12,color:#fff
                style D fill:#f39c12,color:#fff
            </div>

            <table>
                <tr>
                    <th>S√≠mbolo</th>
                    <th>Frecuencia</th>
                    <th>C√≥digo Huffman</th>
                    <th>ASCII (8 bits)</th>
                </tr>
                <tr><td>A</td><td>5</td><td><strong>11</strong> (2 bits)</td><td>01000001</td></tr>
                <tr><td>B</td><td>2</td><td><strong>00</strong> (2 bits)</td><td>01000010</td></tr>
                <tr><td>R</td><td>2</td><td><strong>01</strong> (2 bits)</td><td>01010010</td></tr>
                <tr><td>C</td><td>1</td><td><strong>100</strong> (3 bits)</td><td>01000011</td></tr>
                <tr><td>D</td><td>1</td><td><strong>101</strong> (3 bits)</td><td>01000100</td></tr>
            </table>
        </div>

        <div class="concepts">
            <h3>C√°lculo del ahorro</h3>
            <p><strong>ABRACADABRA</strong> (11 caracteres):</p>
            <ul>
                <li><strong>ASCII:</strong> 11 √ó 8 = 88 bits</li>
                <li><strong>Huffman:</strong> 5√ó2 + 2√ó2 + 2√ó2 + 1√ó3 + 1√ó3 = 10 + 4 + 4 + 3 + 3 = 24 bits</li>
                <li><strong>Compresi√≥n:</strong> (88-24)/88 = <strong>72.7% de ahorro</strong></li>
            </ul>
        </div>

        <div class="design-note">
            <strong>üîß Pregunta frecuente: ¬øC√≥mo sabe el descompresor qu√© √°rbol usar?</strong><br>
            En la pr√°ctica, el archivo comprimido incluye:
            <ul>
                <li><strong>Opci√≥n 1:</strong> La tabla de frecuencias al inicio (el descompresor reconstruye el √°rbol).</li>
                <li><strong>Opci√≥n 2:</strong> El √°rbol serializado (ej: representaci√≥n can√≥nica).</li>
                <li><strong>Opci√≥n 3:</strong> C√≥digos can√≥nicos de Huffman (solo longitudes, el √°rbol se deriva).</li>
            </ul>
            <p>Este "overhead" es peque√±o comparado con el ahorro, especialmente en archivos grandes.</p>
        </div>

        <div class="application">
            <h3>üí° Aplicaciones de Huffman</h3>
            <ul>
                <li><strong>ZIP, GZIP, DEFLATE:</strong> Huffman como parte del algoritmo de compresi√≥n.</li>
                <li><strong>JPEG, PNG:</strong> Compresi√≥n de im√°genes usa variantes de Huffman.</li>
                <li><strong>MP3:</strong> Codificaci√≥n Huffman para audio comprimido.</li>
                <li><strong>Fax:</strong> Codificaci√≥n de im√°genes en blanco y negro.</li>
            </ul>
        </div>

        <div class="warning">
            <h3>‚ö†Ô∏è Limitaciones de Huffman</h3>
            <ul>
                <li>Requiere conocer las frecuencias de antemano (o dos pasadas).</li>
                <li>El √°rbol debe transmitirse junto con los datos comprimidos.</li>
                <li>No explota patrones repetitivos (mejor usar LZ77/LZ78 + Huffman).</li>
                <li>Codificaci√≥n aritm√©tica puede ser m√°s eficiente pero m√°s compleja.</li>
            </ul>
        </div>
    </section>

    <!-- ERRORES COMUNES -->
    <section id="errores">
        <h2>‚ö†Ô∏è Errores frecuentes en estructuras arb√≥reas</h2>
        <table>
            <tr>
                <th>Error t√≠pico</th>
                <th>¬øPor qu√© ocurre?</th>
                <th>Correcci√≥n / prueba mental</th>
            </tr>
            <tr>
                <td><strong>No actualizar alturas despu√©s de rotaci√≥n AVL</strong></td>
                <td>Se olvida que las alturas cambian al reestructurar</td>
                <td>Siempre recalcular altura de nodos afectados de abajo hacia arriba</td>
            </tr>
            <tr>
                <td><strong>Confundir casos LR y RL</strong></td>
                <td>Los nombres son sim√©tricos y confusos</td>
                <td>LR: desbalance izq (+2), hijo va derecha (-1) ‚Üí izq luego der</td>
            </tr>
            <tr>
                <td><strong>Eliminar en BST sin considerar los 3 casos</strong></td>
                <td>El caso de 2 hijos es el m√°s complejo</td>
                <td>Siempre encontrar sucesor inorden, copiar valor, eliminar sucesor</td>
            </tr>
            <tr>
                <td><strong>Olvidar enlazar hojas en B+</strong></td>
                <td>Se implementa como B-tree normal</td>
                <td>Las hojas deben tener puntero al siguiente para recorrido secuencial</td>
            </tr>
            <tr>
                <td><strong>Huffman: crear c√≥digo que no es prefijo</strong></td>
                <td>No usar estructura de √°rbol correctamente</td>
                <td>Verificar: ning√∫n c√≥digo puede ser inicio de otro</td>
            </tr>
            <tr>
                <td><strong>Confundir preorden con notaci√≥n prefija</strong></td>
                <td>Son lo mismo solo para √°rboles de expresi√≥n</td>
                <td>Preorden es orden de visita; prefija es notaci√≥n matem√°tica</td>
            </tr>
        </table>

        <div class="warning">
            <h3>ü§ñ Cuidado con alucinaciones de IA en estructuras de datos</h3>
            <p>Las LLMs (incluyendo ChatGPT, Claude, etc.) pueden cometer errores espec√≠ficos con √°rboles:</p>
            <ul>
                <li><strong>Inventar rotaciones:</strong> Describir una "rotaci√≥n triple" o secuencias que no existen.</li>
                <li><strong>Calcular mal el factor de balance:</strong> Especialmente en ejemplos con muchos nodos.</li>
                <li><strong>C√≥digo con bugs sutiles:</strong> Actualizar alturas en orden incorrecto, o no manejar bien los casos l√≠mite.</li>
                <li><strong>Confundir B-tree con B+:</strong> Mezclar propiedades de ambas estructuras.</li>
            </ul>
            <p><strong>Regla de oro:</strong> Siempre verifica las respuestas de la IA con el simulador visual o ejecutando el c√≥digo con casos de prueba propios.</p>
        </div>
    </section>

    <!-- C√ìDIGO PYTHON -->
    <section id="codigo">
        <h2>üíª Implementaci√≥n en Python</h2>

        <h3>√Årbol Binario de B√∫squeda (BST) - Completo con eliminaci√≥n</h3>
        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">üìã Copiar c√≥digo</button>
            <pre><code>class NodoBST:
    def __init__(self, valor):
        self.valor = valor
        self.izquierdo = None
        self.derecho = None

class BST:
    """
    √Årbol Binario de B√∫squeda.
    
    Decisi√≥n de dise√±o: No permite duplicados (act√∫a como conjunto).
    Para permitir duplicados, se podr√≠a:
    - Agregar un contador en cada nodo
    - Insertar duplicados sistem√°ticamente a la izquierda o derecha
    """
    
    def __init__(self):
        self.raiz = None
    
    def insertar(self, valor):
        """Inserta un valor en el BST."""
        if not self.raiz:
            self.raiz = NodoBST(valor)
        else:
            self._insertar_recursivo(self.raiz, valor)
    
    def _insertar_recursivo(self, nodo, valor):
        if valor < nodo.valor:
            if nodo.izquierdo is None:
                nodo.izquierdo = NodoBST(valor)
            else:
                self._insertar_recursivo(nodo.izquierdo, valor)
        elif valor > nodo.valor:
            if nodo.derecho is None:
                nodo.derecho = NodoBST(valor)
            else:
                self._insertar_recursivo(nodo.derecho, valor)
        # Si valor == nodo.valor, no insertamos (sin duplicados)
    
    def buscar(self, valor):
        """Busca un valor en el BST. Retorna True si existe."""
        return self._buscar_recursivo(self.raiz, valor)
    
    def _buscar_recursivo(self, nodo, valor):
        if nodo is None:
            return False
        if valor == nodo.valor:
            return True
        elif valor < nodo.valor:
            return self._buscar_recursivo(nodo.izquierdo, valor)
        else:
            return self._buscar_recursivo(nodo.derecho, valor)
    
    def eliminar(self, valor):
        """
        Elimina un valor del BST.
        Maneja los 3 casos: hoja, un hijo, dos hijos.
        """
        self.raiz = self._eliminar_recursivo(self.raiz, valor)
    
    def _eliminar_recursivo(self, nodo, valor):
        # Caso base: no encontramos el valor
        if nodo is None:
            return None
        
        # Buscar el nodo a eliminar
        if valor < nodo.valor:
            nodo.izquierdo = self._eliminar_recursivo(nodo.izquierdo, valor)
        elif valor > nodo.valor:
            nodo.derecho = self._eliminar_recursivo(nodo.derecho, valor)
        else:
            # ¬°Encontramos el nodo a eliminar!
            
            # CASO 1: Nodo hoja (sin hijos)
            if nodo.izquierdo is None and nodo.derecho is None:
                return None
            
            # CASO 2a: Solo tiene hijo derecho
            if nodo.izquierdo is None:
                return nodo.derecho
            
            # CASO 2b: Solo tiene hijo izquierdo
            if nodo.derecho is None:
                return nodo.izquierdo
            
            # CASO 3: Tiene dos hijos
            # Encontrar el sucesor inorden (m√≠nimo del sub√°rbol derecho)
            sucesor = self._encontrar_minimo(nodo.derecho)
            
            # Copiar el valor del sucesor al nodo actual
            nodo.valor = sucesor.valor
            
            # Eliminar el sucesor del sub√°rbol derecho
            nodo.derecho = self._eliminar_recursivo(nodo.derecho, sucesor.valor)
        
        return nodo
    
    def _encontrar_minimo(self, nodo):
        """Encuentra el nodo con valor m√≠nimo (ir siempre a la izquierda)."""
        actual = nodo
        while actual.izquierdo is not None:
            actual = actual.izquierdo
        return actual
    
    def inorden(self):
        """Recorrido inorden (produce elementos ordenados)."""
        resultado = []
        self._inorden_recursivo(self.raiz, resultado)
        return resultado
    
    def _inorden_recursivo(self, nodo, resultado):
        if nodo:
            self._inorden_recursivo(nodo.izquierdo, resultado)
            resultado.append(nodo.valor)
            self._inorden_recursivo(nodo.derecho, resultado)
    
    def preorden(self):
        """Recorrido preorden."""
        resultado = []
        self._preorden_recursivo(self.raiz, resultado)
        return resultado
    
    def _preorden_recursivo(self, nodo, resultado):
        if nodo:
            resultado.append(nodo.valor)
            self._preorden_recursivo(nodo.izquierdo, resultado)
            self._preorden_recursivo(nodo.derecho, resultado)
    
    def postorden(self):
        """Recorrido postorden."""
        resultado = []
        self._postorden_recursivo(self.raiz, resultado)
        return resultado
    
    def _postorden_recursivo(self, nodo, resultado):
        if nodo:
            self._postorden_recursivo(nodo.izquierdo, resultado)
            self._postorden_recursivo(nodo.derecho, resultado)
            resultado.append(nodo.valor)
    
    def minimo(self):
        """Encuentra el valor m√≠nimo."""
        if not self.raiz:
            return None
        return self._encontrar_minimo(self.raiz).valor
    
    def maximo(self):
        """Encuentra el valor m√°ximo."""
        if not self.raiz:
            return None
        nodo = self.raiz
        while nodo.derecho:
            nodo = nodo.derecho
        return nodo.valor

# Ejemplo de uso con pruebas de eliminaci√≥n
if __name__ == "__main__":
    bst = BST()
    valores = [50, 30, 70, 20, 40, 60, 80]
    
    print("Insertando:", valores)
    for v in valores:
        bst.insertar(v)
    
    print("Inorden:", bst.inorden())
    
    # Probar eliminaci√≥n - Caso 1: hoja
    print("\nEliminando 20 (hoja)...")
    bst.eliminar(20)
    print("Inorden:", bst.inorden())
    
    # Probar eliminaci√≥n - Caso 2: un hijo
    print("\nInsertando 25, eliminando 30 (un hijo)...")
    bst.insertar(25)
    bst.eliminar(30)
    print("Inorden:", bst.inorden())
    
    # Probar eliminaci√≥n - Caso 3: dos hijos
    print("\nEliminando 50 (dos hijos, ra√≠z)...")
    bst.eliminar(50)
    print("Inorden:", bst.inorden())</code></pre>
        </div>

        <h3>√Årbol AVL con rotaciones</h3>
        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">üìã Copiar c√≥digo</button>
            <pre><code>class NodoAVL:
    def __init__(self, valor):
        self.valor = valor
        self.izquierdo = None
        self.derecho = None
        self.altura = 1  # Altura del nodo (hoja = 1)

class AVL:
    def __init__(self):
        self.raiz = None
    
    def altura(self, nodo):
        """Retorna la altura de un nodo (0 si es None)."""
        return nodo.altura if nodo else 0
    
    def factor_balance(self, nodo):
        """Calcula el factor de balance: altura(izq) - altura(der)."""
        if not nodo:
            return 0
        return self.altura(nodo.izquierdo) - self.altura(nodo.derecho)
    
    def actualizar_altura(self, nodo):
        """Actualiza la altura de un nodo bas√°ndose en sus hijos."""
        nodo.altura = 1 + max(self.altura(nodo.izquierdo), 
                              self.altura(nodo.derecho))
    
    def rotacion_derecha(self, z):
        """
        Rotaci√≥n simple a la derecha (caso LL).
              z                y
             / \              / \
            y   T4    ‚Üí      x   z
           / \              / \ / \
          x   T3           T1 T2 T3 T4
         / \
        T1  T2
        """
        y = z.izquierdo
        T3 = y.derecho
        
        # Realizar rotaci√≥n
        y.derecho = z
        z.izquierdo = T3
        
        # Actualizar alturas (¬°ORDEN IMPORTA!)
        # Primero z, luego y. ¬øPor qu√©?
        # Despu√©s de la rotaci√≥n, z es HIJO de y.
        # La altura de y depende de la altura de z.
        # Si calcul√°ramos y primero, usar√≠amos la altura vieja de z (incorrecta).
        self.actualizar_altura(z)
        self.actualizar_altura(y)
        
        return y  # Nueva ra√≠z del sub√°rbol
    
    def rotacion_izquierda(self, z):
        """
        Rotaci√≥n simple a la izquierda (caso RR).
            z                   y
           / \                 / \
          T1  y       ‚Üí       z   x
             / \             / \ / \
            T2  x           T1 T2 T3 T4
               / \
              T3  T4
        """
        y = z.derecho
        T2 = y.izquierdo
        
        # Realizar rotaci√≥n
        y.izquierdo = z
        z.derecho = T2
        
        # Actualizar alturas
        self.actualizar_altura(z)
        self.actualizar_altura(y)
        
        return y  # Nueva ra√≠z del sub√°rbol
    
    def insertar(self, valor):
        """Inserta un valor y rebalancea si es necesario."""
        self.raiz = self._insertar_recursivo(self.raiz, valor)
    
    def _insertar_recursivo(self, nodo, valor):
        # 1. Inserci√≥n BST normal
        if not nodo:
            return NodoAVL(valor)
        
        if valor < nodo.valor:
            nodo.izquierdo = self._insertar_recursivo(nodo.izquierdo, valor)
        elif valor > nodo.valor:
            nodo.derecho = self._insertar_recursivo(nodo.derecho, valor)
        else:
            return nodo  # Sin duplicados
        
        # 2. Actualizar altura del nodo actual
        self.actualizar_altura(nodo)
        
        # 3. Obtener factor de balance
        fb = self.factor_balance(nodo)
        
        # 4. Aplicar rotaciones si est√° desbalanceado
        
        # Caso LL: desbalance izquierdo-izquierdo
        if fb > 1 and valor < nodo.izquierdo.valor:
            return self.rotacion_derecha(nodo)
        
        # Caso RR: desbalance derecho-derecho
        if fb < -1 and valor > nodo.derecho.valor:
            return self.rotacion_izquierda(nodo)
        
        # Caso LR: desbalance izquierdo-derecho (rotaci√≥n doble)
        if fb > 1 and valor > nodo.izquierdo.valor:
            nodo.izquierdo = self.rotacion_izquierda(nodo.izquierdo)
            return self.rotacion_derecha(nodo)
        
        # Caso RL: desbalance derecho-izquierdo (rotaci√≥n doble)
        if fb < -1 and valor < nodo.derecho.valor:
            nodo.derecho = self.rotacion_derecha(nodo.derecho)
            return self.rotacion_izquierda(nodo)
        
        return nodo
    
    def inorden(self):
        """Recorrido inorden."""
        resultado = []
        self._inorden(self.raiz, resultado)
        return resultado
    
    def _inorden(self, nodo, resultado):
        if nodo:
            self._inorden(nodo.izquierdo, resultado)
            resultado.append((nodo.valor, self.factor_balance(nodo)))
            self._inorden(nodo.derecho, resultado)
    
    def mostrar_estructura(self):
        """Muestra la estructura del √°rbol con factores de balance."""
        def _mostrar(nodo, nivel=0, prefijo="Ra√≠z: "):
            if nodo:
                print(" " * (nivel * 4) + prefijo + 
                      f"{nodo.valor} (FB={self.factor_balance(nodo)}, h={nodo.altura})")
                if nodo.izquierdo or nodo.derecho:
                    _mostrar(nodo.izquierdo, nivel + 1, "Izq: ")
                    _mostrar(nodo.derecho, nivel + 1, "Der: ")
        _mostrar(self.raiz)

# Ejemplo de uso
if __name__ == "__main__":
    avl = AVL()
    
    # Insertar en orden (causar√≠a degeneraci√≥n en BST normal)
    print("Insertando: 10, 20, 30, 40, 50, 25")
    for valor in [10, 20, 30, 40, 50, 25]:
        avl.insertar(valor)
        print(f"\nDespu√©s de insertar {valor}:")
        avl.mostrar_estructura()
    
    print("\nInorden con FB:", avl.inorden())</code></pre>
        </div>

        <h3>√Årbol de Huffman para compresi√≥n</h3>
        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">üìã Copiar c√≥digo</button>
            <pre><code>import heapq
from collections import Counter

class NodoHuffman:
    def __init__(self, caracter, frecuencia):
        self.caracter = caracter  # None para nodos internos
        self.frecuencia = frecuencia
        self.izquierdo = None
        self.derecho = None
    
    def __lt__(self, otro):
        # Para que heapq compare por frecuencia
        return self.frecuencia < otro.frecuencia
    
    def es_hoja(self):
        return self.izquierdo is None and self.derecho is None

class Huffman:
    """
    Implementaci√≥n de codificaci√≥n Huffman.
    
    Nota sobre archivos reales: El archivo comprimido debe incluir
    informaci√≥n para reconstruir el √°rbol. Opciones comunes:
    1. Guardar la tabla de frecuencias al inicio
    2. Serializar el √°rbol (ej: recorrido preorden con marcadores)
    3. Usar c√≥digos can√≥nicos (solo guardar longitudes)
    """
    
    def __init__(self):
        self.raiz = None
        self.codigos = {}
        self.codigos_inversos = {}
    
    def construir_arbol(self, texto):
        """Construye el √°rbol de Huffman a partir de un texto."""
        # 1. Calcular frecuencias
        frecuencias = Counter(texto)
        
        if len(frecuencias) == 0:
            return
        
        # Caso especial: un solo car√°cter
        if len(frecuencias) == 1:
            char = list(frecuencias.keys())[0]
            self.raiz = NodoHuffman(char, frecuencias[char])
            self.codigos[char] = '0'
            self.codigos_inversos['0'] = char
            return
        
        # 2. Crear cola de prioridad con nodos hoja
        heap = []
        for caracter, freq in frecuencias.items():
            nodo = NodoHuffman(caracter, freq)
            heapq.heappush(heap, nodo)
        
        # 3. Construir √°rbol combinando nodos
        while len(heap) > 1:
            # Extraer los dos nodos con menor frecuencia
            izq = heapq.heappop(heap)
            der = heapq.heappop(heap)
            
            # Crear nodo padre
            padre = NodoHuffman(None, izq.frecuencia + der.frecuencia)
            padre.izquierdo = izq
            padre.derecho = der
            
            # Reinsertar en la cola
            heapq.heappush(heap, padre)
        
        # 4. El √∫nico nodo restante es la ra√≠z
        self.raiz = heap[0]
        
        # 5. Generar c√≥digos
        self._generar_codigos(self.raiz, "")
    
    def _generar_codigos(self, nodo, codigo_actual):
        """Genera c√≥digos binarios recorriendo el √°rbol."""
        if nodo is None:
            return
        
        if nodo.es_hoja():
            self.codigos[nodo.caracter] = codigo_actual
            self.codigos_inversos[codigo_actual] = nodo.caracter
            return
        
        # 0 para izquierda, 1 para derecha
        self._generar_codigos(nodo.izquierdo, codigo_actual + "0")
        self._generar_codigos(nodo.derecho, codigo_actual + "1")
    
    def codificar(self, texto):
        """Codifica un texto usando los c√≥digos de Huffman."""
        return ''.join(self.codigos[c] for c in texto)
    
    def decodificar(self, bits):
        """Decodifica una cadena de bits."""
        resultado = []
        nodo_actual = self.raiz
        
        for bit in bits:
            if bit == '0':
                nodo_actual = nodo_actual.izquierdo
            else:
                nodo_actual = nodo_actual.derecho
            
            if nodo_actual.es_hoja():
                resultado.append(nodo_actual.caracter)
                nodo_actual = self.raiz
        
        return ''.join(resultado)
    
    def mostrar_codigos(self):
        """Muestra la tabla de c√≥digos."""
        print("\nTabla de c√≥digos Huffman:")
        print("-" * 40)
        for caracter, codigo in sorted(self.codigos.items(), 
                                        key=lambda x: (len(x[1]), x[1])):
            print(f"'{caracter}': {codigo:>10} ({len(codigo)} bits)")
    
    def calcular_compresion(self, texto):
        """Calcula estad√≠sticas de compresi√≥n."""
        bits_original = len(texto) * 8  # ASCII
        bits_huffman = len(self.codificar(texto))
        
        print(f"\nEstad√≠sticas de compresi√≥n:")
        print(f"  Texto original: {len(texto)} caracteres")
        print(f"  Bits ASCII (8 bits/char): {bits_original}")
        print(f"  Bits Huffman: {bits_huffman}")
        print(f"  Compresi√≥n: {(1 - bits_huffman/bits_original)*100:.1f}%")
        print(f"  Ratio: {bits_huffman/bits_original:.3f}")
        
        # Nota sobre overhead del √°rbol
        overhead_estimado = len(self.codigos) * 10  # Estimaci√≥n simple
        print(f"  (Nota: En archivo real, agregar ~{overhead_estimado} bits para el √°rbol)")

# Ejemplo de uso
if __name__ == "__main__":
    texto = "ABRACADABRA"
    print(f"Texto original: '{texto}'")
    
    huff = Huffman()
    huff.construir_arbol(texto)
    huff.mostrar_codigos()
    
    # Codificar
    codificado = huff.codificar(texto)
    print(f"\nCodificado: {codificado}")
    
    # Decodificar
    decodificado = huff.decodificar(codificado)
    print(f"Decodificado: {decodificado}")
    
    # Verificar
    assert texto == decodificado, "¬°Error en codificaci√≥n/decodificaci√≥n!"
    print("‚úì Verificaci√≥n exitosa")
    
    # Estad√≠sticas
    huff.calcular_compresion(texto)</code></pre>
        </div>

        <h3>Evaluador de expresiones postfijas</h3>
        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">üìã Copiar c√≥digo</button>
            <pre><code>def evaluar_postfija(expresion):
    """
    Eval√∫a una expresi√≥n en notaci√≥n postfija (RPN).
    
    Conexi√≥n con √°rboles: El recorrido POSTORDEN de un √°rbol de expresi√≥n
    genera exactamente esta notaci√≥n, que luego puede evaluarse linealmente.
    
    Args:
        expresion: string con tokens separados por espacios
                   Ejemplo: "3 4 + 2 *" = (3 + 4) * 2 = 14
    
    Returns:
        El resultado num√©rico de la expresi√≥n
    """
    pila = []
    operadores = {
        '+': lambda a, b: a + b,
        '-': lambda a, b: a - b,
        '*': lambda a, b: a * b,
        '/': lambda a, b: a / b,
        '^': lambda a, b: a ** b,
        '%': lambda a, b: a % b,
    }
    
    tokens = expresion.split()
    
    for token in tokens:
        if token in operadores:
            # Es un operador: extraer dos operandos
            if len(pila) < 2:
                raise ValueError(f"Expresi√≥n inv√°lida: faltan operandos para '{token}'")
            
            b = pila.pop()  # Segundo operando (arriba de la pila)
            a = pila.pop()  # Primer operando
            resultado = operadores[token](a, b)
            pila.append(resultado)
        else:
            # Es un operando: convertir a n√∫mero y apilar
            try:
                numero = float(token)
                pila.append(numero)
            except ValueError:
                raise ValueError(f"Token inv√°lido: '{token}'")
    
    if len(pila) != 1:
        raise ValueError("Expresi√≥n inv√°lida: sobran operandos")
    
    return pila[0]

# Ejemplos de uso
if __name__ == "__main__":
    ejemplos = [
        ("3 4 +", "(3 + 4)"),
        ("3 4 + 2 *", "(3 + 4) * 2"),
        ("5 1 2 + 4 * + 3 -", "5 + (1 + 2) * 4 - 3"),
        ("2 3 ^ 4 +", "2^3 + 4"),
    ]
    
    print("Evaluaci√≥n de expresiones postfijas:")
    print("=" * 60)
    for postfija, infija in ejemplos:
        resultado = evaluar_postfija(postfija)
        print(f"  Postfija: {postfija:25} | Infija: {infija:20} = {resultado}")</code></pre>
        </div>
    </section>

    <!-- ACTIVIDADES IA -->
    <section id="ia-activities">
        <h2>ü§ñ Actividades con IA (Semana 8)</h2>

        <div class="warning">
            <h3>‚ö†Ô∏è Uso cr√≠tico de IA en estructuras de datos</h3>
            <p>Las LLMs pueden cometer errores con √°rboles. <strong>Siempre verifica</strong> las respuestas de la IA:</p>
            <ul>
                <li>Usa el <a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html" target="_blank">simulador visual de AVL</a> para confirmar rotaciones.</li>
                <li>Ejecuta el c√≥digo generado con casos de prueba propios.</li>
                <li>Verifica manualmente los factores de balance en ejemplos peque√±os.</li>
            </ul>
        </div>

        <div class="ia-activity">
            <h3><span class="prompt-number">1</span> Predicci√≥n y verificaci√≥n de rotaciones AVL</h3>
            <p><strong>Enfoque activo:</strong> T√∫ predices, la IA verifica.</p>
            <div class="ia-prompt">Voy a proponerte una secuencia de inserciones en un AVL y MI PREDICCI√ìN de qu√© rotaci√≥n ocurrir√°. Verifica si mi predicci√≥n es correcta.

Secuencia: [30, 20, 25]

MI PREDICCI√ìN:
- Despu√©s de insertar 30: √°rbol con solo la ra√≠z 30
- Despu√©s de insertar 20: 30 tiene hijo izquierdo 20, FB(30)=+1
- Despu√©s de insertar 25: 
  - 25 va a la derecha de 20
  - FB(30) = +2 (desbalanceado)
  - FB(20) = -1 (hijo va a la derecha)
  - Esto es caso LR, necesita rotaci√≥n doble

¬øEs correcta mi predicci√≥n? Si hay errores, expl√≠came d√≥nde me equivoqu√© paso a paso.</div>
        </div>

        <div class="ia-activity">
            <h3><span class="prompt-number">2</span> Depuraci√≥n de implementaci√≥n de eliminaci√≥n BST</h3>
            <div class="ia-prompt">[INSTRUCCIONES: Pega tu c√≥digo de BST con el m√©todo eliminar y un caso de prueba que falla]

Tengo esta implementaci√≥n de eliminaci√≥n en BST:

```python
# [PEGAR TU C√ìDIGO AQU√ç]
```

Caso de prueba:
```python
bst = BST()
for v in [50, 30, 70, 20, 40, 60, 80]:
    bst.insertar(v)
bst.eliminar(70)  # Nodo con dos hijos
print(bst.inorden())  # Esperado: [20, 30, 40, 50, 60, 80]
                      # Obtenido: [resultado incorrecto o error]
```

Tareas:
1. Identifica si el error est√° en el manejo de alguno de los 3 casos
2. Muestra la ejecuci√≥n paso a paso para mi caso de prueba
3. Corrige el c√≥digo con comentarios explicativos
4. Dame 3 casos de prueba adicionales que cubran cada caso de eliminaci√≥n</div>
        </div>

        <div class="ia-activity">
            <h3><span class="prompt-number">3</span> Dise√±o de esquema de compresi√≥n Huffman</h3>
            <div class="ia-prompt">Contexto: Necesito comprimir un archivo de texto con las siguientes caracter√≠sticas:
- Idioma: espa√±ol
- Tipo: [especificar: c√≥digo fuente / texto literario / datos tabulares / logs]
- Tama√±o aproximado: [especificar]

Tarea:
1. Estima las frecuencias t√≠picas de caracteres para ese tipo de texto en espa√±ol.
2. Construye un √°rbol de Huffman basado en esas frecuencias estimadas.
3. Genera la tabla de c√≥digos resultante.
4. Calcula la compresi√≥n te√≥rica esperada vs ASCII.
5. Explica c√≥mo se guardar√≠a el √°rbol en el archivo comprimido.

Pregunta adicional: ¬øQu√© pasar√≠a si el texto real tiene frecuencias muy diferentes a las estimadas?</div>
        </div>

        <div class="ia-activity">
            <h3><span class="prompt-number">4</span> Comparaci√≥n de estructuras para indexaci√≥n</h3>
            <div class="ia-prompt">Contexto: Estoy dise√±ando un sistema y debo elegir la estructura de √≠ndice adecuada.

Escenario:
- Tabla con [especificar cantidad] de registros
- Operaciones frecuentes: [b√∫squedas puntuales / rangos / inserciones frecuentes]
- Almacenamiento: [SSD / HDD / memoria RAM]
- Tama√±o de bloque de disco: 4KB

Tarea:
1. Compara BST, AVL, B-tree y B+ tree para este escenario.
2. Calcula para cada uno:
   - Altura esperada
   - Accesos a disco por b√∫squeda
   - Ventajas/desventajas espec√≠ficas
3. Recomienda la estructura √≥ptima con justificaci√≥n.

IMPORTANTE: Muestra los c√°lculos para que yo pueda verificarlos.</div>
        </div>

        <div class="checklist">
            <h3>‚úÖ R√∫brica de uso √©tico de IA (auto-revisi√≥n)</h3>
            <ul>
                <li><input type="checkbox" aria-label="Atribuci√≥n"> Document√© qu√© partes fueron apoyadas por IA en mi c√≥digo o reporte.</li>
                <li><input type="checkbox" aria-label="Comprensi√≥n"> Puedo explicar las rotaciones AVL dibuj√°ndolas en papel sin consultar.</li>
                <li><input type="checkbox" aria-label="Validaci√≥n"> Verifiqu√© las respuestas de la IA con el simulador o ejecutando c√≥digo.</li>
                <li><input type="checkbox" aria-label="Casos propios"> Dise√±√© casos de prueba propios, no solo us√© los sugeridos por la IA.</li>
                <li><input type="checkbox" aria-label="Reflexi√≥n"> Escrib√≠ un p√°rrafo sobre qu√© errores cometi√≥ la IA (si los hubo) y c√≥mo los detect√©.</li>
            </ul>
        </div>
    </section>

    <!-- PROYECTO -->
    <section id="proyecto" class="project">
        <h2>üöÄ Proyecto integrador ‚Äì Avance Semana 8</h2>

        <div style="display: grid; grid-template-columns: repeat(auto-fit,minmax(280px,1fr)); gap: 20px;">
            <div>
                <h3>Sistema de indexaci√≥n y compresi√≥n</h3>
                <p>Desarrolla un mini-sistema que combine las estructuras de esta semana:</p>
                
                <div class="design-note" style="margin: 10px 0;">
                    <strong>üîß Aclaraci√≥n importante:</strong> Son dos funcionalidades <em>complementarias pero independientes</em> sobre el mismo texto fuente:
                    <ul>
                        <li><strong>Indexaci√≥n:</strong> Para buscar palabras r√°pidamente (BST/AVL sobre el texto original)</li>
                        <li><strong>Compresi√≥n:</strong> Para ahorrar espacio en disco (generar archivo <code>.huff</code>)</li>
                    </ul>
                    No se trata de indexar el texto comprimido ni de comprimir el √≠ndice.
                </div>
                
                <ul>
                    <li><strong>M√≥dulo de √≠ndice:</strong> BST o AVL que indexe palabras del documento original con sus posiciones (l√≠nea, columna).</li>
                    <li><strong>M√≥dulo de compresi√≥n:</strong> Huffman para generar una versi√≥n comprimida del documento (archivo <code>.huff</code>).</li>
                    <li><strong>Consultas:</strong> Interfaz para buscar palabras y mostrar contexto (l√≠neas donde aparecen).</li>
                </ul>
            </div>
            <div>
                <h3>Entregables sugeridos</h3>
                <ul>
                    <li>C√≥digo organizado en m√≥dulos: <code>bst.py</code>, <code>avl.py</code>, <code>huffman.py</code>, <code>main.py</code>.</li>
                    <li>Archivo de prueba: texto de al menos 1000 palabras.</li>
                    <li>Reporte (3-4 p√°ginas):
                        <ul>
                            <li>Descripci√≥n de la arquitectura.</li>
                            <li>An√°lisis de complejidad de cada operaci√≥n.</li>
                            <li>Estad√≠sticas de compresi√≥n lograda.</li>
                            <li>Comparaci√≥n BST vs AVL (tiempos, alturas).</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>

        <div class="checklist">
            <h3>‚úÖ R√∫brica de evaluaci√≥n del proyecto</h3>
            <table>
                <tr>
                    <th>Criterio</th>
                    <th>Puntos</th>
                    <th>Descripci√≥n</th>
                </tr>
                <tr>
                    <td><strong>Implementaci√≥n BST/AVL</strong></td>
                    <td>25</td>
                    <td>Operaciones correctas (insertar, buscar, <strong>eliminar</strong>). AVL mantiene balance despu√©s de cada operaci√≥n.</td>
                </tr>
                <tr>
                    <td><strong>Implementaci√≥n Huffman</strong></td>
                    <td>25</td>
                    <td>Construcci√≥n correcta del √°rbol. Codificaci√≥n y decodificaci√≥n verificables.</td>
                </tr>
                <tr>
                    <td><strong>Integraci√≥n y funcionalidad</strong></td>
                    <td>20</td>
                    <td>El sistema completo funciona: indexa, comprime, permite consultas.</td>
                </tr>
                <tr>
                    <td><strong>An√°lisis y documentaci√≥n</strong></td>
                    <td>15</td>
                    <td>Reporte claro con an√°lisis de complejidad, estad√≠sticas y comparaciones.</td>
                </tr>
                <tr>
                    <td><strong>Uso √©tico de IA</strong></td>
                    <td>15</td>
                    <td>Evidencia de comprensi√≥n propia. Verificaci√≥n de respuestas de IA. Atribuci√≥n clara.</td>
                </tr>
            </table>
        </div>

        <div class="checklist">
            <h3>Checklist r√°pido antes de entregar</h3>
            <ul>
                <li><input type="checkbox"> Puedo dibujar una rotaci√≥n LR en papel explicando cada paso.</li>
                <li><input type="checkbox"> Mi BST implementa correctamente los 3 casos de eliminaci√≥n.</li>
                <li><input type="checkbox"> Mi AVL pasa casos de prueba con las 4 rotaciones (LL, RR, LR, RL).</li>
                <li><input type="checkbox"> Mi Huffman comprime y descomprime correctamente cualquier texto ASCII.</li>
                <li><input type="checkbox"> Compar√© el rendimiento de BST vs AVL con datos ordenados y aleatorios.</li>
                <li><input type="checkbox"> Verifiqu√© las respuestas de IA con el simulador o casos de prueba propios.</li>
            </ul>
        </div>
    </section>

    <!-- RETO GAMIFICADO -->
    <section id="reto">
        <div class="gamification">
            <h2>üèÜ Desaf√≠o del Diccionario Maldito</h2>
            <p><strong>Escenario:</strong> El bibliotecario malvado del pueblo insert√≥ las 10,000 palabras de su diccionario en un BST... ¬°pero las insert√≥ en orden alfab√©tico! Ahora cada b√∫squeda toma una eternidad.</p>
            
            <p><strong>Tu misi√≥n:</strong></p>
            <ol>
                <li>Calcula exactamente cu√°ntas comparaciones se necesitan para buscar la palabra "zorro" en ese BST degenerado (asume que est√° en la posici√≥n 9,500).</li>
                <li>Si convirtieras ese BST en un AVL, ¬øcu√°l ser√≠a la altura m√°xima y cu√°ntas comparaciones necesitar√≠as?</li>
                <li>El bibliotecario ofrece un trato: te da las palabras en cualquier orden que elijas, pero solo tienes un BST b√°sico (sin AVL). ¬øQu√© orden de inserci√≥n minimizar√≠a la altura?</li>
            </ol>
            
            <details>
                <summary>üí° Ver soluci√≥n</summary>
                <div style="padding: 15px; background: #f9f9f9; border-radius: 5px; margin-top: 10px;">
                    <p><strong>1. BST degenerado:</strong> Con inserci√≥n alfab√©tica, el √°rbol es una lista. "zorro" en posici√≥n 9,500 requiere exactamente <strong>9,500 comparaciones</strong> (recorrer desde la ra√≠z hasta ese nodo).</p>
                    
                    <p><strong>2. AVL:</strong> Altura m√°xima ‚âà 1.44 √ó log‚ÇÇ(10,000) ‚âà 1.44 √ó 13.3 ‚âà <strong>19</strong>. B√∫squeda: m√°ximo <strong>19 comparaciones</strong>. ¬°500 veces m√°s r√°pido!</p>
                    
                    <p><strong>3. Orden √≥ptimo para BST b√°sico:</strong> Insertar en orden de "b√∫squeda binaria":
                    <ul>
                        <li>Primero la mediana (palabra #5,000)</li>
                        <li>Luego las medianas de cada mitad (#2,500 y #7,500)</li>
                        <li>Continuar recursivamente</li>
                    </ul>
                    Esto produce un √°rbol perfectamente balanceado con altura = ‚åàlog‚ÇÇ(10,001)‚åâ = <strong>14</strong>.</p>
                    
                    <p><strong>Lecci√≥n:</strong> El orden de inserci√≥n determina la forma del BST. Un AVL elimina esta dependencia a costa de operaciones extra en cada inserci√≥n.</p>
                    
                    <div style="margin-top: 15px; padding: 10px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
                        <strong>üí° Nota t√©cnica para curiosos:</strong> Si intentas crear el √°rbol degenerado de 10,000 nodos en Python con la implementaci√≥n recursiva del curso, recibir√°s un <code>RecursionError</code>. Esto ocurre porque Python limita la profundidad de recursi√≥n (usualmente a ~1,000 llamadas). Para simularlo, tendr√≠as que:
                        <ul style="margin: 10px 0 0 20px;">
                            <li>Aumentar el l√≠mite: <code>import sys; sys.setrecursionlimit(15000)</code></li>
                            <li>O mejor: implementar una versi√≥n iterativa usando un bucle <code>while</code></li>
                        </ul>
                        <em>¬°Este es un ejemplo real de c√≥mo las limitaciones del lenguaje afectan nuestras estructuras de datos!</em>
                    </div>
                </div>
            </details>
        </div>

        <div class="gamification">
            <h2>üéÆ Bonus: El C√≥digo Morse Optimizado</h2>
            <p><strong>Dato curioso:</strong> El c√≥digo Morse fue dise√±ado (intuitivamente) siguiendo principios similares a Huffman: 'E' (la letra m√°s frecuente en ingl√©s) es solo un punto (.), mientras que 'Q' (poco frecuente) es "- - ¬∑ -".</p>
            
            <p><strong>Mini-reto:</strong> Si Samuel Morse hubiera tenido una computadora en 1840, ¬øhabr√≠a creado exactamente el mismo c√≥digo? Investiga las frecuencias del ingl√©s y compara.</p>
            
            <details>
                <summary>üí° Pista</summary>
                <p>Las frecuencias que Morse estim√≥ no eran exactas (cont√≥ tipos de imprenta en una imprenta local, no texto real). Adem√°s, Morse prioriz√≥ que el c√≥digo fuera:</p>
                <ul>
                    <li>F√°cil de recordar para operadores humanos</li>
                    <li>Distinguible auditivamente (evitar confusiones entre s√≠mbolos similares)</li>
                    <li>Pr√°ctico de transmitir manualmente con un tel√©grafo</li>
                </ul>
                <p>¬°La ingenier√≠a real siempre tiene m√°s restricciones que la teor√≠a pura!</p>
            </details>
        </div>
    </section>

    <footer>
        <p>Semana 8 ‚Äì Estructuras de Datos Arb√≥reas Especializadas | Estructuras de Datos Avanzadas</p>
        <p>Dr. Eligardo Cruz S√°nchez | Universidad Aut√≥noma de Nayarit</p>
        <p><em>Versi√≥n 2.1 ‚Äì Correcciones t√©cnicas y pedag√≥gicas adicionales</em></p>
    </footer>
</div>

<script>
function copyCode(button) {
    const codeBlock = button.nextElementSibling.querySelector('code');
    const textToCopy = codeBlock.textContent;
    
    navigator.clipboard.writeText(textToCopy).then(() => {
        const originalText = button.textContent;
        button.textContent = '‚úÖ ¬°Copiado!';
        button.classList.add('copied');
        
        setTimeout(() => {
            button.textContent = originalText;
            button.classList.remove('copied');
        }, 2000);
    }).catch(err => {
        console.error('Error al copiar:', err);
        button.textContent = '‚ùå Error';
        setTimeout(() => {
            button.textContent = 'üìã Copiar c√≥digo';
        }, 2000);
    });
}
</script>

</body>
</html>
